/**
 * REST API handlers for translation admin
 * For use with Next.js API routes, Express, or any Node.js server
 *
 * @example Next.js App Router
 * ```ts
 * // app/api/admin/translations/route.ts
 * import { createRestHandlers } from '@sylphx/rosetta-admin/server';
 * import { storage } from '@/lib/rosetta';
 * import { createOpenRouterTranslator } from '@sylphx/rosetta-admin/ai';
 *
 * const handlers = createRestHandlers({
 *   storage,
 *   translator: createOpenRouterTranslator({
 *     apiKey: process.env.OPENROUTER_API_KEY!,
 *   }),
 * });
 *
 * export const GET = handlers.GET;
 * export const PUT = handlers.PUT;
 * export const PATCH = handlers.PATCH;
 * ```
 *
 * ```ts
 * // app/api/admin/translations/batch/route.ts
 * export const POST = handlers.batchTranslate;
 * ```
 */

import type { AdminServiceConfig } from './service';
import { createAdminService } from './service';

export interface RestHandlersConfig extends AdminServiceConfig {
	/**
	 * Authorization function (optional)
	 * Return false to reject the request
	 */
	authorize?: (request: Request) => Promise<boolean>;
}

export interface RestHandlers {
	/** GET: Fetch translations, stats, locales */
	GET: (request: Request) => Promise<Response>;
	/** PUT: Save a single translation */
	PUT: (request: Request) => Promise<Response>;
	/** PATCH: Mark as reviewed */
	PATCH: (request: Request) => Promise<Response>;
	/** POST: Batch translate */
	batchTranslate: (request: Request) => Promise<Response>;
}

/**
 * Create REST API handlers
 */
export function createRestHandlers(config: RestHandlersConfig): RestHandlers {
	const { authorize, ...serviceConfig } = config;
	const service = createAdminService(serviceConfig);

	async function checkAuth(request: Request): Promise<Response | null> {
		if (authorize) {
			const authorized = await authorize(request);
			if (!authorized) {
				return Response.json({ error: 'Unauthorized' }, { status: 401 });
			}
		}
		return null;
	}

	return {
		async GET(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const data = await service.fetchTranslations();
				return Response.json(data);
			} catch (error) {
				console.error('Failed to fetch translations:', error);
				return Response.json({ error: 'Failed to fetch translations' }, { status: 500 });
			}
		},

		async PUT(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { sourceHash, locale, translatedText, autoGenerated, translatedFrom } = body;

				if (!sourceHash || !locale || translatedText === undefined) {
					return Response.json(
						{ error: 'sourceHash, locale, and translatedText are required' },
						{ status: 400 }
					);
				}

				await service.saveTranslation({
					sourceHash,
					locale,
					translatedText,
					autoGenerated,
					translatedFrom,
				});

				return Response.json({ success: true });
			} catch (error) {
				console.error('Failed to save translation:', error);
				return Response.json({ error: 'Failed to save translation' }, { status: 500 });
			}
		},

		async PATCH(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { sourceHash, locale } = body;

				if (!sourceHash || !locale) {
					return Response.json({ error: 'sourceHash and locale are required' }, { status: 400 });
				}

				await service.markAsReviewed({ sourceHash, locale });

				return Response.json({ success: true });
			} catch (error) {
				console.error('Failed to mark as reviewed:', error);
				return Response.json({ error: 'Failed to mark as reviewed' }, { status: 500 });
			}
		},

		async batchTranslate(request: Request): Promise<Response> {
			const authError = await checkAuth(request);
			if (authError) return authError;

			try {
				const body = await request.json();
				const { locale, hashes } = body;

				if (!locale || locale === 'en') {
					return Response.json({ error: 'Valid non-English locale is required' }, { status: 400 });
				}

				const result = await service.batchTranslate({ locale, hashes });

				return Response.json(result);
			} catch (error) {
				console.error('Batch translation failed:', error);
				return Response.json(
					{ error: error instanceof Error ? error.message : 'Batch translation failed' },
					{ status: 500 }
				);
			}
		},
	};
}

/**
 * Server-side business logic for translation admin
 * Works with any StorageAdapter from @sylphx/rosetta
 */

import type { StorageAdapter } from '@sylphx/rosetta';
import type {
	BatchTranslateRequest,
	BatchTranslateResponse,
	FetchTranslationsResponse,
	LocaleStats,
	MarkAsReviewedRequest,
	SaveTranslationRequest,
	SourceEntry,
	TranslateFunction,
	TranslationData,
} from '../core/types';

export interface AdminServiceConfig {
	/** Storage adapter from rosetta */
	storage: StorageAdapter;
	/** AI translation function (optional) */
	translator?: TranslateFunction;
	/** Function to get enabled locales (optional) */
	getEnabledLocales?: () => Promise<string[]>;
}

/**
 * Create admin service with business logic
 */
export function createAdminService(config: AdminServiceConfig) {
	const { storage, translator, getEnabledLocales } = config;

	/**
	 * Get all active locales (enabled + those with translations)
	 */
	async function getActiveLocales(): Promise<string[]> {
		const [enabledLocales, localesWithTranslations] = await Promise.all([
			getEnabledLocales?.() ?? [],
			storage.getAvailableLocales(),
		]);

		// Merge and dedupe, excluding 'en' (source language)
		const allLocales = [
			...new Set([...enabledLocales, ...localesWithTranslations.filter((l) => l !== 'en')]),
		];

		// Sort: locales with translations first
		return allLocales.sort((a, b) => {
			const aHas = localesWithTranslations.includes(a);
			const bHas = localesWithTranslations.includes(b);
			if (aHas && !bHas) return -1;
			if (!aHas && bHas) return 1;
			return a.localeCompare(b);
		});
	}

	/**
	 * Get effective source text (considering override)
	 */
	function getEffectiveSourceText(
		codeText: string,
		translations: Record<string, { text: string | null; translatedFrom?: string | null } | null>
	): string {
		const enOverride = translations['en']?.text;
		return enOverride || codeText;
	}

	/**
	 * Check if translation is outdated
	 */
	function isTranslationOutdated(
		translation: { text: string | null; translatedFrom?: string | null } | null,
		effectiveSource: string
	): boolean {
		if (!translation?.text || !translation.translatedFrom) {
			return false;
		}
		return translation.translatedFrom !== effectiveSource;
	}

	/**
	 * Fetch all translations data
	 */
	async function fetchTranslations(): Promise<FetchTranslationsResponse> {
		const locales = await getActiveLocales();

		// Always include 'en' to check for source overrides
		const localesWithEn = locales.includes('en') ? locales : ['en', ...locales];

		if (!storage.getSourcesWithTranslations) {
			throw new Error('Storage adapter must implement getSourcesWithTranslations for admin');
		}

		const rawSources = await storage.getSourcesWithTranslations(localesWithEn);
		const allSources = await storage.getSources();
		const totalStrings = allSources.length;

		// Transform to SourceEntry format
		const sources: SourceEntry[] = rawSources.map((source) => {
			const effectiveSource = getEffectiveSourceText(source.text, source.translations);

			const translations: Record<string, TranslationData | null> = {};
			for (const locale of locales) {
				const t = source.translations[locale];
				if (t) {
					const outdated = locale !== 'en' && isTranslationOutdated(t, effectiveSource);
					translations[locale] = {
						text: t.text,
						auto: t.autoGenerated,
						reviewed: t.reviewed,
						translatedFrom: t.translatedFrom,
						outdated,
					};
				} else {
					translations[locale] = null;
				}
			}

			return {
				sourceHash: source.hash,
				sourceText: source.text,
				effectiveSource,
				context: source.context,
				translations,
			};
		});

		// Calculate stats
		const stats: Record<string, LocaleStats> = {};
		for (const locale of locales) {
			let translated = 0;
			let reviewed = 0;
			let outdated = 0;

			for (const source of sources) {
				const t = source.translations[locale];
				if (t?.text) {
					translated++;
					if (t.reviewed) reviewed++;
					if (t.outdated) outdated++;
				}
			}

			stats[locale] = { translated, reviewed, outdated, total: totalStrings };
		}

		return {
			sources,
			stats: { totalStrings, locales: stats },
			locales,
		};
	}

	/**
	 * Save a single translation
	 */
	async function saveTranslation(request: SaveTranslationRequest): Promise<void> {
		await storage.saveTranslation(request.locale, request.sourceHash, request.translatedText, {
			autoGenerated: request.autoGenerated ?? false,
			translatedFrom: request.translatedFrom,
		});
	}

	/**
	 * Mark translation as reviewed
	 */
	async function markAsReviewed(request: MarkAsReviewedRequest): Promise<void> {
		if (!storage.markAsReviewed) {
			throw new Error('Storage adapter does not support markAsReviewed');
		}
		await storage.markAsReviewed(request.locale, request.sourceHash);
	}

	/**
	 * Batch translate using AI
	 * Server-first: finds untranslated strings from storage
	 */
	async function batchTranslate(request: BatchTranslateRequest): Promise<BatchTranslateResponse> {
		if (!translator) {
			throw new Error('No translator configured');
		}

		const { locale, hashes } = request;

		// Get sources to translate
		let sources: Array<{ hash: string; text: string; context?: string | null }>;

		if (hashes && hashes.length > 0) {
			// Specific hashes requested
			const allSources = await storage.getSources();
			const hashSet = new Set(hashes);
			sources = allSources
				.filter((s) => hashSet.has(s.hash))
				.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
		} else {
			// Translate all missing
			const untranslated = await storage.getUntranslated(locale);
			sources = untranslated.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
		}

		if (sources.length === 0) {
			return { success: true, translated: 0, total: 0, translations: [] };
		}

		// Build items for translator
		const items = sources.map((source) => ({
			sourceHash: source.hash,
			sourceText: source.text,
			context: source.context,
		}));

		// Call translator
		const translations = await translator(items, locale);

		// Build source map for saving
		const sourceMap = new Map(sources.map((s) => [s.hash, s.text]));

		// Save translations
		let savedCount = 0;
		for (const t of translations) {
			try {
				const sourceText = sourceMap.get(t.sourceHash);
				await storage.saveTranslation(locale, t.sourceHash, t.translatedText, {
					autoGenerated: true,
					translatedFrom: sourceText,
				});
				savedCount++;
			} catch (err) {
				console.error(`Failed to save translation for ${t.sourceHash}:`, err);
			}
		}

		return {
			success: true,
			translated: savedCount,
			total: sources.length,
			translations,
		};
	}

	return {
		getActiveLocales,
		fetchTranslations,
		saveTranslation,
		markAsReviewed,
		batchTranslate,
	};
}

export type AdminService = ReturnType<typeof createAdminService>;

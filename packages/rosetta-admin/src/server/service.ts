/**
 * Server-side business logic for translation admin
 * Works with any StorageAdapter from @sylphx/rosetta
 */

import { hashText, type StorageAdapter } from '@sylphx/rosetta';
import type {
	BatchStreamEvent,
	BatchTranslateRequest,
	BatchTranslateResponse,
	FetchTranslationsResponse,
	LocaleStats,
	MarkAsReviewedRequest,
	SaveTranslationRequest,
	SourceEntry,
	TranslateFunction,
	TranslationData,
} from '../core/types';

export interface AdminServiceConfig {
	/** Storage adapter from rosetta */
	storage: StorageAdapter;
	/** AI translation function (optional) */
	translator?: TranslateFunction;
	/** Function to get enabled locales (optional) */
	getEnabledLocales?: () => Promise<string[]>;
	/** Batch size for streaming translation (default: 30) */
	batchSize?: number;
	/**
	 * Function to get source strings from manifest.
	 * If provided, sources are read from manifest instead of DB.
	 * This is the new architecture - sources are static files, not in DB.
	 */
	getManifestSources?: () => Promise<Array<{ hash: string; text: string; context?: string }>>;
}

/**
 * Create admin service with business logic
 */
export function createAdminService(config: AdminServiceConfig) {
	const { storage, translator, getEnabledLocales, batchSize = 30, getManifestSources } = config;

	/**
	 * Get all active locales (enabled + those with translations)
	 */
	async function getActiveLocales(): Promise<string[]> {
		const [enabledLocales, localesWithTranslations] = await Promise.all([
			getEnabledLocales?.() ?? [],
			storage.getAvailableLocales(),
		]);

		// Merge and dedupe, excluding 'en' (source language)
		const allLocales = [
			...new Set([...enabledLocales, ...localesWithTranslations.filter((l) => l !== 'en')]),
		];

		// Sort: locales with translations first
		return allLocales.sort((a, b) => {
			const aHas = localesWithTranslations.includes(a);
			const bHas = localesWithTranslations.includes(b);
			if (aHas && !bHas) return -1;
			if (!aHas && bHas) return 1;
			return a.localeCompare(b);
		});
	}

	/**
	 * Get effective source text (considering override)
	 */
	function getEffectiveSourceText(
		codeText: string,
		translations: Record<string, { text: string | null; sourceHash?: string | null; translatedFrom?: string | null } | null>
	): string {
		const enOverride = translations['en']?.text;
		return enOverride || codeText;
	}

	/**
	 * Check if translation is outdated
	 * Uses sourceHash (preferred) or falls back to translatedFrom (deprecated)
	 */
	function isTranslationOutdated(
		translation: { text: string | null; sourceHash?: string | null; translatedFrom?: string | null } | null,
		effectiveSource: string
	): boolean {
		if (!translation?.text) {
			return false;
		}

		// Prefer sourceHash comparison (8 char hex, O(1) comparison)
		if (translation.sourceHash) {
			const currentHash = hashText(effectiveSource);
			return translation.sourceHash !== currentHash;
		}

		// Fall back to translatedFrom comparison (deprecated, full text comparison)
		if (translation.translatedFrom) {
			return translation.translatedFrom !== effectiveSource;
		}

		return false;
	}

	/**
	 * Fetch all translations data
	 */
	async function fetchTranslations(): Promise<FetchTranslationsResponse> {
		const locales = await getActiveLocales();

		// Always include 'en' to check for source overrides
		const localesWithEn = locales.includes('en') ? locales : ['en', ...locales];

		let sources: SourceEntry[];
		let totalStrings: number;

		if (getManifestSources) {
			// NEW ARCHITECTURE: Sources from manifest, translations from DB
			const [manifestSources, translationsData] = await Promise.all([
				getManifestSources(),
				storage.getSourcesWithTranslations
					? storage.getSourcesWithTranslations(localesWithEn)
					: Promise.resolve([]),
			]);

			totalStrings = manifestSources.length;

			// Build a map of hash -> translations for quick lookup
			const translationsMap = new Map(
				translationsData.map((src) => [src.hash, src.translations])
			);

			// Join manifest sources with translations from DB
			sources = manifestSources.map((source) => {
				const dbTranslations = translationsMap.get(source.hash) || {};
				const effectiveSource = getEffectiveSourceText(source.text, dbTranslations);

				const translations: Record<string, TranslationData | null> = {};
				for (const locale of locales) {
					const t = dbTranslations[locale];
					if (t) {
						const outdated = locale !== 'en' && isTranslationOutdated(t, effectiveSource);
						translations[locale] = {
							text: t.text,
							auto: t.autoGenerated,
							reviewed: t.reviewed,
							translatedFrom: t.translatedFrom,
							outdated,
						};
					} else {
						translations[locale] = null;
					}
				}

				return {
					sourceHash: source.hash,
					sourceText: source.text,
					effectiveSource,
					context: source.context,
					translations,
				};
			});
		} else {
			// OLD ARCHITECTURE: Sources and translations from DB (backwards compat)
			if (!storage.getSourcesWithTranslations) {
				throw new Error('Storage adapter must implement getSourcesWithTranslations for admin');
			}

			const rawSources = await storage.getSourcesWithTranslations(localesWithEn);
			const allSources = await storage.getSources();
			totalStrings = allSources.length;

			// Transform to SourceEntry format
			sources = rawSources.map((source) => {
				const effectiveSource = getEffectiveSourceText(source.text, source.translations);

				const translations: Record<string, TranslationData | null> = {};
				for (const locale of locales) {
					const t = source.translations[locale];
					if (t) {
						const outdated = locale !== 'en' && isTranslationOutdated(t, effectiveSource);
						translations[locale] = {
							text: t.text,
							auto: t.autoGenerated,
							reviewed: t.reviewed,
							translatedFrom: t.translatedFrom,
							outdated,
						};
					} else {
						translations[locale] = null;
					}
				}

				return {
					sourceHash: source.hash,
					sourceText: source.text,
					effectiveSource,
					context: source.context,
					translations,
				};
			});
		}

		// Calculate stats
		const stats: Record<string, LocaleStats> = {};
		for (const locale of locales) {
			let translated = 0;
			let reviewed = 0;
			let outdated = 0;

			for (const source of sources) {
				const t = source.translations[locale];
				if (t?.text) {
					translated++;
					if (t.reviewed) reviewed++;
					if (t.outdated) outdated++;
				}
			}

			stats[locale] = { translated, reviewed, outdated, total: totalStrings };
		}

		return {
			sources,
			stats: { totalStrings, locales: stats },
			locales,
		};
	}

	/**
	 * Save a single translation
	 */
	async function saveTranslation(request: SaveTranslationRequest): Promise<void> {
		await storage.saveTranslation(request.locale, request.sourceHash, request.translatedText, {
			autoGenerated: request.autoGenerated ?? false,
			// Use sourceHash for staleness detection (compact, 8 char hex)
			sourceHash: request.translatedFrom ? hashText(request.translatedFrom) : undefined,
			// Also set translatedFrom for backward compat with older adapters
			translatedFrom: request.translatedFrom,
		});
	}

	/**
	 * Mark translation as reviewed
	 */
	async function markAsReviewed(request: MarkAsReviewedRequest): Promise<void> {
		if (!storage.markAsReviewed) {
			throw new Error('Storage adapter does not support markAsReviewed');
		}
		await storage.markAsReviewed(request.locale, request.sourceHash);
	}

	/**
	 * Batch translate using AI
	 * Server-first: finds untranslated strings from storage
	 */
	async function batchTranslate(request: BatchTranslateRequest): Promise<BatchTranslateResponse> {
		if (!translator) {
			throw new Error('No translator configured');
		}

		const { locale, hashes } = request;

		// Get sources to translate
		let sources: Array<{ hash: string; text: string; context?: string | null }>;

		if (hashes && hashes.length > 0) {
			// Specific hashes requested
			const allSources = await storage.getSources();
			const hashSet = new Set(hashes);
			sources = allSources
				.filter((s) => hashSet.has(s.hash))
				.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
		} else {
			// Translate all missing
			const untranslated = await storage.getUntranslated(locale);
			sources = untranslated.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
		}

		if (sources.length === 0) {
			return { success: true, translated: 0, total: 0, translations: [] };
		}

		// Build items for translator
		const items = sources.map((source) => ({
			sourceHash: source.hash,
			sourceText: source.text,
			context: source.context,
		}));

		// Call translator
		const translations = await translator(items, locale);

		// Build source map for saving
		const sourceMap = new Map(sources.map((s) => [s.hash, s.text]));

		// Save translations
		let savedCount = 0;
		for (const t of translations) {
			try {
				const sourceText = sourceMap.get(t.sourceHash);
				await storage.saveTranslation(locale, t.sourceHash, t.translatedText, {
					autoGenerated: true,
					sourceHash: sourceText ? hashText(sourceText) : undefined,
					translatedFrom: sourceText,
				});
				savedCount++;
			} catch (err) {
				console.error(`Failed to save translation for ${t.sourceHash}:`, err);
			}
		}

		return {
			success: true,
			translated: savedCount,
			total: sources.length,
			translations,
		};
	}

	/**
	 * Batch translate using AI with streaming progress
	 * Yields events as each batch completes
	 */
	async function* batchTranslateStream(
		request: BatchTranslateRequest
	): AsyncGenerator<BatchStreamEvent> {
		if (!translator) {
			yield { type: 'error', message: 'No translator configured' };
			return;
		}

		const { locale, hashes } = request;

		// Get sources to translate
		let sources: Array<{ hash: string; text: string; context?: string | null }>;

		try {
			if (hashes && hashes.length > 0) {
				// Specific hashes requested
				const allSources = await storage.getSources();
				const hashSet = new Set(hashes);
				sources = allSources
					.filter((s) => hashSet.has(s.hash))
					.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
			} else {
				// Translate all missing
				const untranslated = await storage.getUntranslated(locale);
				sources = untranslated.map((s) => ({ hash: s.hash, text: s.text, context: s.context }));
			}
		} catch (err) {
			yield { type: 'error', message: err instanceof Error ? err.message : 'Failed to get sources' };
			return;
		}

		const total = sources.length;

		if (total === 0) {
			yield { type: 'complete', success: true, translated: 0, total: 0 };
			return;
		}

		// Emit initial progress
		yield { type: 'progress', current: 0, total };

		let savedCount = 0;

		// Process in batches
		for (let i = 0; i < sources.length; i += batchSize) {
			const batch = sources.slice(i, i + batchSize);

			// Build items for translator
			const items = batch.map((source) => ({
				sourceHash: source.hash,
				sourceText: source.text,
				context: source.context,
			}));

			try {
				// Call translator for this batch
				const translations = await translator(items, locale);

				// Build source map for saving
				const sourceMap = new Map(batch.map((s) => [s.hash, s.text]));

				// Save translations and emit events
				for (const t of translations) {
					try {
						const sourceText = sourceMap.get(t.sourceHash);
						await storage.saveTranslation(locale, t.sourceHash, t.translatedText, {
							autoGenerated: true,
							sourceHash: sourceText ? hashText(sourceText) : undefined,
							translatedFrom: sourceText,
						});
						savedCount++;

						// Emit translation event
						yield {
							type: 'translation',
							sourceHash: t.sourceHash,
							translatedText: t.translatedText,
						};
					} catch (err) {
						console.error(`Failed to save translation for ${t.sourceHash}:`, err);
					}
				}

				// Emit progress after batch
				yield { type: 'progress', current: Math.min(i + batchSize, total), total };
			} catch (err) {
				yield {
					type: 'error',
					message: err instanceof Error ? err.message : 'Translation batch failed',
				};
				return;
			}
		}

		// Emit completion
		yield { type: 'complete', success: true, translated: savedCount, total };
	}

	return {
		getActiveLocales,
		fetchTranslations,
		saveTranslation,
		markAsReviewed,
		batchTranslate,
		batchTranslateStream,
	};
}

export type AdminService = ReturnType<typeof createAdminService>;

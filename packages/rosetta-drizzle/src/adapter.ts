/**
 * Drizzle Storage Adapter for @sylphx/rosetta
 *
 * @example
 * ```ts
 * import { drizzle } from 'drizzle-orm/postgres-js';
 * import postgres from 'postgres';
 * import { DrizzleStorageAdapter } from '@sylphx/rosetta-drizzle';
 * import { rosettaSources, rosettaTranslations } from './schema';
 *
 * const client = postgres(process.env.DATABASE_URL!);
 * const db = drizzle(client);
 *
 * const storage = new DrizzleStorageAdapter({
 *   db,
 *   sources: rosettaSources,
 *   translations: rosettaTranslations,
 * });
 *
 * const rosetta = new Rosetta({
 *   storage,
 *   defaultLocale: 'en',
 * });
 * ```
 */

import type { SourceString, SourceWithStatus, StorageAdapter } from '@sylphx/rosetta';
import { and, eq, inArray, notInArray, sql } from 'drizzle-orm';

// ============================================
// Types
// ============================================

/**
 * Generic Drizzle table type for sources
 */
export interface RosettaSourcesTableType {
	id: unknown;
	hash: unknown;
	text: unknown;
	context: unknown;
	occurrences: unknown;
	firstSeenAt: unknown;
	lastSeenAt: unknown;
}

/**
 * Generic Drizzle table type for translations
 */
export interface RosettaTranslationsTableType {
	id: unknown;
	locale: unknown;
	hash: unknown;
	text: unknown;
	autoGenerated: unknown;
	reviewed: unknown;
	createdAt: unknown;
	updatedAt: unknown;
}

/**
 * Drizzle database instance type (generic to support all dialects)
 */
export interface DrizzleDatabase {
	select: (...args: unknown[]) => unknown;
	insert: (...args: unknown[]) => unknown;
	update: (...args: unknown[]) => unknown;
	delete: (...args: unknown[]) => unknown;
}

/**
 * Configuration for DrizzleStorageAdapter
 */
export interface DrizzleStorageAdapterConfig<
	TDB extends DrizzleDatabase,
	TSources extends Record<string, unknown>,
	TTranslations extends Record<string, unknown>,
> {
	/**
	 * Drizzle database instance
	 */
	db: TDB;
	/**
	 * Rosetta sources table created by createRosettaSchema
	 */
	sources: TSources;
	/**
	 * Rosetta translations table created by createRosettaSchema
	 */
	translations: TTranslations;
}

// ============================================
// Adapter Implementation
// ============================================

/**
 * Drizzle ORM Storage Adapter
 *
 * Implements the full StorageAdapter interface including admin methods.
 * Works with PostgreSQL, MySQL, and SQLite via Drizzle ORM.
 */
export class DrizzleStorageAdapter<
	TDB extends DrizzleDatabase,
	TSources extends Record<string, unknown>,
	TTranslations extends Record<string, unknown>,
> implements StorageAdapter
{
	private db: TDB;
	private sources: TSources;
	private translations: TTranslations;

	constructor(config: DrizzleStorageAdapterConfig<TDB, TSources, TTranslations>) {
		this.db = config.db;
		this.sources = config.sources;
		this.translations = config.translations;
	}

	// ============================================
	// Core Methods
	// ============================================

	/**
	 * Get all translations for a locale
	 */
	async getTranslations(locale: string): Promise<Map<string, string>> {
		const db = this.db as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		const results = (await (db.select as CallableFunction)({
			hash: translations.hash,
			text: translations.text,
		})
			.from(this.translations)
			.where(eq(translations.locale as Parameters<typeof eq>[0], locale))) as Array<{
			hash: string;
			text: string;
		}>;

		const map = new Map<string, string>();
		for (const row of results) {
			map.set(row.hash, row.text);
		}
		return map;
	}

	/**
	 * Register source strings (batch insert, skip duplicates)
	 */
	async registerSources(
		items: Array<{
			text: string;
			hash: string;
			context?: string;
		}>
	): Promise<void> {
		if (items.length === 0) return;

		const db = this.db as Record<string, unknown>;
		const sources = this.sources as Record<string, unknown>;

		// Get existing hashes
		const hashes = items.map((i) => i.hash);
		const existing = (await (db.select as CallableFunction)({ hash: sources.hash })
			.from(this.sources)
			.where(inArray(sources.hash as Parameters<typeof inArray>[0], hashes))) as Array<{
			hash: string;
		}>;

		const existingSet = new Set(existing.map((e) => e.hash));

		// Filter to new items only
		const newItems = items.filter((i) => !existingSet.has(i.hash));
		if (newItems.length === 0) return;

		// Insert new items
		const now = new Date();
		await (db.insert as CallableFunction)(this.sources)
			.values(
				newItems.map((item) => ({
					hash: item.hash,
					text: item.text,
					context: item.context ?? null,
					occurrences: 1,
					firstSeenAt: now,
					lastSeenAt: now,
				}))
			)
			.onConflictDoNothing();

		// Update occurrences for existing items
		const existingItems = items.filter((i) => existingSet.has(i.hash));
		for (const item of existingItems) {
			await (db.update as CallableFunction)(this.sources)
				.set({
					occurrences: sql`${sources.occurrences} + 1`,
					lastSeenAt: now,
				})
				.where(eq(sources.hash as Parameters<typeof eq>[0], item.hash));
		}
	}

	/**
	 * Save a single translation
	 */
	async saveTranslation(
		locale: string,
		hash: string,
		text: string,
		options?: {
			sourceText?: string;
			context?: string;
			autoGenerated?: boolean;
		}
	): Promise<void> {
		const db = this.db as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		const now = new Date();

		// Upsert translation
		await (db.insert as CallableFunction)(this.translations)
			.values({
				locale,
				hash,
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
				createdAt: now,
				updatedAt: now,
			})
			.onConflictDoUpdate({
				target: [translations.locale, translations.hash],
				set: {
					text,
					autoGenerated: options?.autoGenerated ?? false,
					updatedAt: now,
				},
			});

		// If sourceText provided, ensure source exists
		if (options?.sourceText) {
			await this.registerSources([{ text: options.sourceText, hash, context: options.context }]);
		}
	}

	/**
	 * Get all source strings
	 */
	async getSources(): Promise<SourceString[]> {
		const db = this.db as Record<string, unknown>;
		const sources = this.sources as Record<string, unknown>;

		const results = (await (db.select as CallableFunction)({
			id: sources.id,
			hash: sources.hash,
			text: sources.text,
			context: sources.context,
			occurrences: sources.occurrences,
			lastSeenAt: sources.lastSeenAt,
		}).from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get untranslated strings for a locale
	 */
	async getUntranslated(locale: string): Promise<SourceString[]> {
		const db = this.db as Record<string, unknown>;
		const sources = this.sources as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		// Get hashes that have translations for this locale
		const translatedResults = (await (db.select as CallableFunction)({
			hash: translations.hash,
		})
			.from(this.translations)
			.where(eq(translations.locale as Parameters<typeof eq>[0], locale))) as Array<{
			hash: string;
		}>;

		const translatedHashes = translatedResults.map((r) => r.hash);

		// Get sources that don't have translations
		let query = (db.select as CallableFunction)({
			id: sources.id,
			hash: sources.hash,
			text: sources.text,
			context: sources.context,
			occurrences: sources.occurrences,
			lastSeenAt: sources.lastSeenAt,
		}).from(this.sources);

		if (translatedHashes.length > 0) {
			query = query.where(
				notInArray(sources.hash as Parameters<typeof notInArray>[0], translatedHashes)
			);
		}

		const results = (await query) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get all locales that have at least one translation
	 */
	async getAvailableLocales(): Promise<string[]> {
		const db = this.db as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		// SELECT DISTINCT locale FROM translations
		const results = (await (db.select as CallableFunction)({
			locale: translations.locale,
		})
			.from(this.translations)
			.groupBy(translations.locale)) as Array<{ locale: string }>;

		return results.map((r) => r.locale);
	}

	// ============================================
	// Admin Methods
	// ============================================

	/**
	 * Get all source strings with their translation status for given locales
	 */
	async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
		const db = this.db as Record<string, unknown>;
		const sources = this.sources as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		// Get all sources
		const allSources = (await (db.select as CallableFunction)({
			id: sources.id,
			hash: sources.hash,
			text: sources.text,
			context: sources.context,
		}).from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
		}>;

		// Get all translations for requested locales
		const allTranslations = (await (db.select as CallableFunction)({
			hash: translations.hash,
			locale: translations.locale,
			text: translations.text,
			autoGenerated: translations.autoGenerated,
			reviewed: translations.reviewed,
		})
			.from(this.translations)
			.where(inArray(translations.locale as Parameters<typeof inArray>[0], locales))) as Array<{
			hash: string;
			locale: string;
			text: string;
			autoGenerated: boolean;
			reviewed: boolean;
		}>;

		// Build lookup map: hash -> locale -> translation
		const translationMap = new Map<
			string,
			Map<string, { text: string; autoGenerated: boolean; reviewed: boolean }>
		>();
		for (const t of allTranslations) {
			if (!translationMap.has(t.hash)) {
				translationMap.set(t.hash, new Map());
			}
			translationMap.get(t.hash)!.set(t.locale, {
				text: t.text,
				autoGenerated: t.autoGenerated,
				reviewed: t.reviewed,
			});
		}

		// Build result
		return allSources.map((source) => {
			const sourceTranslations = translationMap.get(source.hash);
			const translationsResult: Record<
				string,
				{ text: string | null; autoGenerated: boolean; reviewed: boolean } | null
			> = {};

			for (const locale of locales) {
				const t = sourceTranslations?.get(locale);
				translationsResult[locale] = t
					? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed }
					: null;
			}

			return {
				id: source.id,
				hash: source.hash,
				text: source.text,
				context: source.context,
				translations: translationsResult,
			};
		});
	}

	/**
	 * Mark a translation as reviewed
	 */
	async markAsReviewed(locale: string, hash: string): Promise<void> {
		const db = this.db as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		await (db.update as CallableFunction)(this.translations)
			.set({ reviewed: true, updatedAt: new Date() })
			.where(
				and(
					eq(translations.locale as Parameters<typeof eq>[0], locale),
					eq(translations.hash as Parameters<typeof eq>[0], hash)
				)
			);
	}

	/**
	 * Save multiple translations at once
	 */
	async saveTranslations(
		locale: string,
		items: Array<{
			hash: string;
			text: string;
			sourceText?: string;
			autoGenerated?: boolean;
		}>
	): Promise<void> {
		for (const item of items) {
			await this.saveTranslation(locale, item.hash, item.text, {
				sourceText: item.sourceText,
				autoGenerated: item.autoGenerated,
			});
		}
	}

	/**
	 * Delete a translation
	 */
	async deleteTranslation(locale: string, hash: string): Promise<void> {
		const db = this.db as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		await (db.delete as CallableFunction)(this.translations).where(
			and(
				eq(translations.locale as Parameters<typeof eq>[0], locale),
				eq(translations.hash as Parameters<typeof eq>[0], hash)
			)
		);
	}

	/**
	 * Delete a source string and all its translations
	 */
	async deleteSource(hash: string): Promise<void> {
		const db = this.db as Record<string, unknown>;
		const sources = this.sources as Record<string, unknown>;
		const translations = this.translations as Record<string, unknown>;

		// Delete all translations for this hash
		await (db.delete as CallableFunction)(this.translations).where(
			eq(translations.hash as Parameters<typeof eq>[0], hash)
		);

		// Delete source
		await (db.delete as CallableFunction)(this.sources).where(
			eq(sources.hash as Parameters<typeof eq>[0], hash)
		);
	}
}

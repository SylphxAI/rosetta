/**
 * Drizzle Storage Adapter for @sylphx/rosetta
 *
 * Type-safe adapter that works with any Drizzle dialect (PostgreSQL, MySQL, SQLite).
 *
 * @example
 * ```ts
 * import { drizzle } from 'drizzle-orm/postgres-js';
 * import postgres from 'postgres';
 * import { DrizzleStorageAdapter } from '@sylphx/rosetta-drizzle';
 * import { rosettaSources, rosettaTranslations } from './schema';
 *
 * const client = postgres(process.env.DATABASE_URL!);
 * const db = drizzle(client);
 *
 * const storage = new DrizzleStorageAdapter({
 *   db,
 *   sources: rosettaSources,
 *   translations: rosettaTranslations,
 * });
 *
 * const rosetta = new Rosetta({
 *   storage,
 *   defaultLocale: 'en',
 * });
 * ```
 */

import type { SourceString, SourceWithStatus, StorageAdapter } from '@sylphx/rosetta';
import { type Column, type SQL, and, eq, inArray, notInArray, sql } from 'drizzle-orm';

// ============================================
// Types
// ============================================

/**
 * Column type constraint - ensures the column exists
 */
type AnyColumn = Column<any, object, object>; // eslint-disable-line @typescript-eslint/no-explicit-any

/**
 * Required columns for sources table
 */
export interface SourcesTableColumns {
	id: AnyColumn;
	hash: AnyColumn;
	text: AnyColumn;
	context: AnyColumn;
	occurrences: AnyColumn;
	firstSeenAt: AnyColumn;
	lastSeenAt: AnyColumn;
}

/**
 * Required columns for translations table
 */
export interface TranslationsTableColumns {
	id: AnyColumn;
	locale: AnyColumn;
	hash: AnyColumn;
	text: AnyColumn;
	/** @deprecated Use sourceHash instead. Will be removed in v1.0 */
	translatedFrom?: AnyColumn;
	/** Hash of source text at translation time (8 char hex, for staleness detection) */
	sourceHash?: AnyColumn;
	autoGenerated: AnyColumn;
	reviewed: AnyColumn;
	createdAt: AnyColumn;
	updatedAt: AnyColumn;
}

/**
 * Drizzle table with required columns
 * These types are structural - any table with the required columns will work
 */
export type SourcesTable = SourcesTableColumns;

export type TranslationsTable = TranslationsTableColumns;

/**
 * Drizzle database query builder interface
 * Supports all dialects (PostgreSQL, MySQL, SQLite)
 */
export interface DrizzleQueryBuilder {
	select<T extends Record<string, AnyColumn>>(
		fields: T
	): {
		from(table: object): {
			where(condition: SQL | undefined): Promise<unknown[]>;
			groupBy(column: AnyColumn): Promise<unknown[]>;
		} & Promise<unknown[]>;
	};
	insert(table: object): {
		values(data: object | object[]): {
			onConflictDoNothing(): Promise<unknown>;
			onConflictDoUpdate(config: { target: AnyColumn[]; set: object }): Promise<unknown>;
		};
	};
	update(table: object): {
		set(data: object): {
			where(condition: SQL | undefined): Promise<unknown>;
		};
	};
	delete(table: object): {
		where(condition: SQL | undefined): Promise<unknown>;
	};
}

/**
 * Configuration for DrizzleStorageAdapter
 *
 * @template S - Sources table type (must have required columns)
 * @template T - Translations table type (must have required columns)
 */
export interface DrizzleStorageAdapterConfig<
	S extends SourcesTable = SourcesTable,
	T extends TranslationsTable = TranslationsTable,
> {
	/**
	 * Drizzle database instance (any dialect)
	 */
	db: DrizzleQueryBuilder;
	/**
	 * Rosetta sources table (must have id, hash, text, context, occurrences, firstSeenAt, lastSeenAt columns)
	 */
	sources: S;
	/**
	 * Rosetta translations table (must have id, locale, hash, text, autoGenerated, reviewed, createdAt, updatedAt columns)
	 */
	translations: T;
}

// ============================================
// Adapter Implementation
// ============================================

/**
 * Drizzle ORM Storage Adapter
 *
 * Type-safe implementation that works with PostgreSQL, MySQL, and SQLite via Drizzle ORM.
 * Implements the full StorageAdapter interface including admin methods.
 *
 * @template S - Sources table type
 * @template T - Translations table type
 */
export class DrizzleStorageAdapter<
	S extends SourcesTable = SourcesTable,
	T extends TranslationsTable = TranslationsTable,
> implements StorageAdapter
{
	private readonly db: DrizzleQueryBuilder;
	private readonly sources: S;
	private readonly translations: T;

	constructor(config: DrizzleStorageAdapterConfig<S, T>) {
		this.db = config.db;
		this.sources = config.sources;
		this.translations = config.translations;

		// Runtime validation for required columns
		this.validateTable(this.sources, 'sources', [
			'id',
			'hash',
			'text',
			'context',
			'occurrences',
			'firstSeenAt',
			'lastSeenAt',
		]);
		this.validateTable(this.translations, 'translations', [
			'id',
			'locale',
			'hash',
			'text',
			'autoGenerated',
			'reviewed',
			'createdAt',
			'updatedAt',
		]);
	}

	/**
	 * Validate that a table has all required columns
	 */
	private validateTable(table: object, name: string, requiredColumns: string[]): void {
		for (const col of requiredColumns) {
			if (!(col in table)) {
				throw new Error(
					`[rosetta-drizzle] ${name} table missing required column: ${col}. ` +
						`Use createRosettaSchema() from @sylphx/rosetta-drizzle/schema to create compatible tables.`
				);
			}
		}
	}

	// ============================================
	// Core Methods
	// ============================================

	/**
	 * Get all translations for a locale
	 */
	async getTranslations(locale: string): Promise<Map<string, string>> {
		const results = (await this.db
			.select({
				hash: this.translations.hash,
				text: this.translations.text,
			})
			.from(this.translations)
			.where(eq(this.translations.locale, locale))) as Array<{
			hash: string;
			text: string;
		}>;

		const map = new Map<string, string>();
		for (const row of results) {
			map.set(row.hash, row.text);
		}
		return map;
	}

	/**
	 * Get translations for specific hashes only (fine-grained loading)
	 * More efficient than getTranslations when you only need a subset
	 */
	async getTranslationsByHashes(locale: string, hashes: string[]): Promise<Map<string, string>> {
		if (hashes.length === 0) {
			return new Map();
		}

		const results = (await this.db
			.select({
				hash: this.translations.hash,
				text: this.translations.text,
			})
			.from(this.translations)
			.where(
				and(eq(this.translations.locale, locale), inArray(this.translations.hash, hashes))
			)) as Array<{
			hash: string;
			text: string;
		}>;

		const map = new Map<string, string>();
		for (const row of results) {
			map.set(row.hash, row.text);
		}
		return map;
	}

	/**
	 * Save a single translation
	 */
	async saveTranslation(
		locale: string,
		hash: string,
		text: string,
		options?: {
			sourceText?: string;
			context?: string;
			autoGenerated?: boolean;
			/** @deprecated Use sourceHash instead */
			translatedFrom?: string;
			/** Hash of source text at translation time (8 char hex, for staleness detection) */
			sourceHash?: string;
		}
	): Promise<void> {
		const now = new Date();

		// Build values object
		const values: Record<string, unknown> = {
			locale,
			hash,
			text,
			autoGenerated: options?.autoGenerated ?? false,
			reviewed: false,
			createdAt: now,
			updatedAt: now,
		};

		// Build update set
		const updateSet: Record<string, unknown> = {
			text,
			autoGenerated: options?.autoGenerated ?? false,
			updatedAt: now,
		};

		// Add sourceHash if the column exists and value is provided (preferred)
		if (this.translations.sourceHash && options?.sourceHash !== undefined) {
			values.sourceHash = options.sourceHash;
			updateSet.sourceHash = options.sourceHash;
		}

		// Add translatedFrom if the column exists and value is provided (deprecated, backward compat)
		if (this.translations.translatedFrom && options?.translatedFrom !== undefined) {
			values.translatedFrom = options.translatedFrom;
			updateSet.translatedFrom = options.translatedFrom;
		}

		// Upsert translation
		await this.db
			.insert(this.translations)
			.values(values)
			.onConflictDoUpdate({
				target: [this.translations.locale, this.translations.hash],
				set: updateSet,
			});
	}

	/**
	 * Get all source strings
	 */
	async getSources(): Promise<SourceString[]> {
		const results = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
				occurrences: this.sources.occurrences,
				lastSeenAt: this.sources.lastSeenAt,
			})
			.from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get untranslated strings for a locale
	 */
	async getUntranslated(locale: string): Promise<SourceString[]> {
		// Get hashes that have translations for this locale
		const translatedResults = (await this.db
			.select({
				hash: this.translations.hash,
			})
			.from(this.translations)
			.where(eq(this.translations.locale, locale))) as Array<{
			hash: string;
		}>;

		const translatedHashes = translatedResults.map((r) => r.hash);

		// Get sources that don't have translations
		const whereCondition =
			translatedHashes.length > 0
				? notInArray(this.sources.hash, translatedHashes)
				: undefined;

		const results = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
				occurrences: this.sources.occurrences,
				lastSeenAt: this.sources.lastSeenAt,
			})
			.from(this.sources)
			.where(whereCondition)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get all locales that have at least one translation
	 */
	async getAvailableLocales(): Promise<string[]> {
		// SELECT DISTINCT locale FROM translations
		const results = (await this.db
			.select({
				locale: this.translations.locale,
			})
			.from(this.translations)
			.groupBy(this.translations.locale)) as Array<{ locale: string }>;

		return results.map((r) => r.locale);
	}

	// ============================================
	// Admin Methods
	// ============================================

	/**
	 * Get all source strings with their translation status for given locales
	 */
	async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
		// Get all sources
		const allSources = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
			})
			.from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
		}>;

		// Build select fields - include sourceHash (preferred) and translatedFrom (deprecated) if columns exist
		const selectFields: Record<string, AnyColumn> = {
			hash: this.translations.hash,
			locale: this.translations.locale,
			text: this.translations.text,
			autoGenerated: this.translations.autoGenerated,
			reviewed: this.translations.reviewed,
		};
		if (this.translations.sourceHash) {
			selectFields.sourceHash = this.translations.sourceHash;
		}
		if (this.translations.translatedFrom) {
			selectFields.translatedFrom = this.translations.translatedFrom;
		}

		// Get all translations for requested locales
		const allTranslations = (await this.db
			.select(selectFields)
			.from(this.translations)
			.where(inArray(this.translations.locale, locales))) as Array<{
			hash: string;
			locale: string;
			text: string;
			autoGenerated: boolean;
			reviewed: boolean;
			sourceHash?: string | null;
			translatedFrom?: string | null;
		}>;

		// Build lookup map: hash -> locale -> translation
		const translationMap = new Map<
			string,
			Map<string, { text: string; autoGenerated: boolean; reviewed: boolean; sourceHash?: string | null; translatedFrom?: string | null }>
		>();
		for (const t of allTranslations) {
			if (!translationMap.has(t.hash)) {
				translationMap.set(t.hash, new Map());
			}
			translationMap.get(t.hash)!.set(t.locale, {
				text: t.text,
				autoGenerated: t.autoGenerated,
				reviewed: t.reviewed,
				sourceHash: t.sourceHash,
				translatedFrom: t.translatedFrom,
			});
		}

		// Build result
		return allSources.map((source) => {
			const sourceTranslations = translationMap.get(source.hash);
			const translationsResult: Record<
				string,
				{ text: string | null; autoGenerated: boolean; reviewed: boolean; sourceHash?: string | null; translatedFrom?: string | null } | null
			> = {};

			for (const locale of locales) {
				const t = sourceTranslations?.get(locale);
				translationsResult[locale] = t
					? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed, sourceHash: t.sourceHash, translatedFrom: t.translatedFrom }
					: null;
			}

			return {
				id: source.id,
				hash: source.hash,
				text: source.text,
				context: source.context,
				translations: translationsResult,
			};
		});
	}

	/**
	 * Mark a translation as reviewed
	 */
	async markAsReviewed(locale: string, hash: string): Promise<void> {
		await this.db
			.update(this.translations)
			.set({ reviewed: true, updatedAt: new Date() })
			.where(
				and(eq(this.translations.locale, locale), eq(this.translations.hash, hash))
			);
	}

	/**
	 * Save multiple translations at once (bulk upsert for performance)
	 * Uses a single INSERT ... ON CONFLICT UPDATE query instead of N queries
	 */
	async saveTranslations(
		locale: string,
		items: Array<{
			hash: string;
			text: string;
			sourceText?: string;
			autoGenerated?: boolean;
			/** @deprecated Use sourceHash instead */
			translatedFrom?: string;
			/** Hash of source text at translation time (8 char hex, for staleness detection) */
			sourceHash?: string;
		}>
	): Promise<void> {
		if (items.length === 0) return;

		const now = new Date();
		const hasSourceHashColumn = !!this.translations.sourceHash;
		const hasTranslatedFromColumn = !!this.translations.translatedFrom;

		// Build values - conditionally include sourceHash and translatedFrom
		const values = items.map((item) => {
			const row: Record<string, unknown> = {
				locale,
				hash: item.hash,
				text: item.text,
				autoGenerated: item.autoGenerated ?? false,
				reviewed: false,
				createdAt: now,
				updatedAt: now,
			};
			if (hasSourceHashColumn && item.sourceHash !== undefined) {
				row.sourceHash = item.sourceHash;
			}
			if (hasTranslatedFromColumn && item.translatedFrom !== undefined) {
				row.translatedFrom = item.translatedFrom;
			}
			return row;
		});

		// Build update set - conditionally include sourceHash and translatedFrom
		const updateSet: Record<string, unknown> = {
			text: sql`excluded.text`,
			autoGenerated: sql`excluded.auto_generated`,
			updatedAt: now,
		};
		if (hasSourceHashColumn) {
			updateSet.sourceHash = sql`excluded.source_hash`;
		}
		if (hasTranslatedFromColumn) {
			updateSet.translatedFrom = sql`excluded.translated_from`;
		}

		// Bulk upsert translations (single query)
		await this.db
			.insert(this.translations)
			.values(values)
			.onConflictDoUpdate({
				target: [this.translations.locale, this.translations.hash],
				set: updateSet,
			});
	}

	/**
	 * Delete a translation
	 */
	async deleteTranslation(locale: string, hash: string): Promise<void> {
		await this.db
			.delete(this.translations)
			.where(
				and(eq(this.translations.locale, locale), eq(this.translations.hash, hash))
			);
	}

	/**
	 * Delete a source string and all its translations
	 */
	async deleteSource(hash: string): Promise<void> {
		// Delete all translations for this hash
		await this.db
			.delete(this.translations)
			.where(eq(this.translations.hash, hash));

		// Delete source
		await this.db
			.delete(this.sources)
			.where(eq(this.sources.hash, hash));
	}
}

/**
 * Drizzle Storage Adapter for @sylphx/rosetta
 *
 * Type-safe adapter that works with any Drizzle dialect (PostgreSQL, MySQL, SQLite).
 *
 * @example
 * ```ts
 * import { drizzle } from 'drizzle-orm/postgres-js';
 * import postgres from 'postgres';
 * import { DrizzleStorageAdapter } from '@sylphx/rosetta-drizzle';
 * import { rosettaSources, rosettaTranslations } from './schema';
 *
 * const client = postgres(process.env.DATABASE_URL!);
 * const db = drizzle(client);
 *
 * const storage = new DrizzleStorageAdapter({
 *   db,
 *   sources: rosettaSources,
 *   translations: rosettaTranslations,
 * });
 *
 * const rosetta = new Rosetta({
 *   storage,
 *   defaultLocale: 'en',
 * });
 * ```
 */

import type { SourceString, SourceWithStatus, StorageAdapter } from '@sylphx/rosetta';
import { type Column, type SQL, and, eq, inArray, notInArray, sql } from 'drizzle-orm';

// ============================================
// Types
// ============================================

/**
 * Column type constraint - ensures the column exists
 */
type AnyColumn = Column<any, object, object>; // eslint-disable-line @typescript-eslint/no-explicit-any

/**
 * Required columns for sources table
 */
export interface SourcesTableColumns {
	id: AnyColumn;
	hash: AnyColumn;
	text: AnyColumn;
	context: AnyColumn;
	occurrences: AnyColumn;
	firstSeenAt: AnyColumn;
	lastSeenAt: AnyColumn;
}

/**
 * Required columns for translations table
 */
export interface TranslationsTableColumns {
	id: AnyColumn;
	locale: AnyColumn;
	hash: AnyColumn;
	text: AnyColumn;
	autoGenerated: AnyColumn;
	reviewed: AnyColumn;
	createdAt: AnyColumn;
	updatedAt: AnyColumn;
}

/**
 * Drizzle table with required columns (type-safe)
 */
export type SourcesTable = SourcesTableColumns & {
	[key: string]: AnyColumn | unknown;
};

export type TranslationsTable = TranslationsTableColumns & {
	[key: string]: AnyColumn | unknown;
};

/**
 * Drizzle database query builder interface
 * Supports all dialects (PostgreSQL, MySQL, SQLite)
 */
export interface DrizzleQueryBuilder {
	select<T extends Record<string, AnyColumn>>(
		fields: T
	): {
		from(table: object): {
			where(condition: SQL | undefined): Promise<unknown[]>;
			groupBy(column: AnyColumn): Promise<unknown[]>;
		} & Promise<unknown[]>;
	};
	insert(table: object): {
		values(data: object | object[]): {
			onConflictDoNothing(): Promise<unknown>;
			onConflictDoUpdate(config: { target: AnyColumn[]; set: object }): Promise<unknown>;
		};
	};
	update(table: object): {
		set(data: object): {
			where(condition: SQL | undefined): Promise<unknown>;
		};
	};
	delete(table: object): {
		where(condition: SQL | undefined): Promise<unknown>;
	};
}

/**
 * Configuration for DrizzleStorageAdapter
 *
 * @template S - Sources table type (must have required columns)
 * @template T - Translations table type (must have required columns)
 */
export interface DrizzleStorageAdapterConfig<
	S extends SourcesTable = SourcesTable,
	T extends TranslationsTable = TranslationsTable,
> {
	/**
	 * Drizzle database instance (any dialect)
	 */
	db: DrizzleQueryBuilder;
	/**
	 * Rosetta sources table (must have id, hash, text, context, occurrences, firstSeenAt, lastSeenAt columns)
	 */
	sources: S;
	/**
	 * Rosetta translations table (must have id, locale, hash, text, autoGenerated, reviewed, createdAt, updatedAt columns)
	 */
	translations: T;
}

// ============================================
// Adapter Implementation
// ============================================

/**
 * Drizzle ORM Storage Adapter
 *
 * Type-safe implementation that works with PostgreSQL, MySQL, and SQLite via Drizzle ORM.
 * Implements the full StorageAdapter interface including admin methods.
 *
 * @template S - Sources table type
 * @template T - Translations table type
 */
export class DrizzleStorageAdapter<
	S extends SourcesTable = SourcesTable,
	T extends TranslationsTable = TranslationsTable,
> implements StorageAdapter
{
	private readonly db: DrizzleQueryBuilder;
	private readonly sources: S;
	private readonly translations: T;

	constructor(config: DrizzleStorageAdapterConfig<S, T>) {
		this.db = config.db;
		this.sources = config.sources;
		this.translations = config.translations;

		// Runtime validation for required columns
		this.validateTable(this.sources, 'sources', [
			'id',
			'hash',
			'text',
			'context',
			'occurrences',
			'firstSeenAt',
			'lastSeenAt',
		]);
		this.validateTable(this.translations, 'translations', [
			'id',
			'locale',
			'hash',
			'text',
			'autoGenerated',
			'reviewed',
			'createdAt',
			'updatedAt',
		]);
	}

	/**
	 * Validate that a table has all required columns
	 */
	private validateTable(table: object, name: string, requiredColumns: string[]): void {
		for (const col of requiredColumns) {
			if (!(col in table)) {
				throw new Error(
					`[rosetta-drizzle] ${name} table missing required column: ${col}. ` +
						`Use createRosettaSchema() from @sylphx/rosetta-drizzle/schema to create compatible tables.`
				);
			}
		}
	}

	// ============================================
	// Core Methods
	// ============================================

	/**
	 * Get all translations for a locale
	 */
	async getTranslations(locale: string): Promise<Map<string, string>> {
		const results = (await this.db
			.select({
				hash: this.translations.hash,
				text: this.translations.text,
			})
			.from(this.translations)
			.where(eq(this.translations.locale, locale))) as Array<{
			hash: string;
			text: string;
		}>;

		const map = new Map<string, string>();
		for (const row of results) {
			map.set(row.hash, row.text);
		}
		return map;
	}

	/**
	 * Get translations for specific hashes only (fine-grained loading)
	 * More efficient than getTranslations when you only need a subset
	 */
	async getTranslationsByHashes(locale: string, hashes: string[]): Promise<Map<string, string>> {
		if (hashes.length === 0) {
			return new Map();
		}

		const results = (await this.db
			.select({
				hash: this.translations.hash,
				text: this.translations.text,
			})
			.from(this.translations)
			.where(
				and(eq(this.translations.locale, locale), inArray(this.translations.hash, hashes))
			)) as Array<{
			hash: string;
			text: string;
		}>;

		const map = new Map<string, string>();
		for (const row of results) {
			map.set(row.hash, row.text);
		}
		return map;
	}

	/**
	 * Register source strings (batch insert, skip duplicates)
	 */
	async registerSources(
		items: Array<{
			text: string;
			hash: string;
			context?: string;
		}>
	): Promise<void> {
		if (items.length === 0) return;

		// Get existing hashes
		const hashes = items.map((i) => i.hash);
		const existing = (await this.db
			.select({ hash: this.sources.hash })
			.from(this.sources)
			.where(inArray(this.sources.hash, hashes))) as Array<{
			hash: string;
		}>;

		const existingSet = new Set(existing.map((e) => e.hash));

		// Filter to new items only
		const newItems = items.filter((i) => !existingSet.has(i.hash));
		if (newItems.length === 0) return;

		// Insert new items
		const now = new Date();
		await this.db
			.insert(this.sources)
			.values(
				newItems.map((item) => ({
					hash: item.hash,
					text: item.text,
					context: item.context ?? null,
					occurrences: 1,
					firstSeenAt: now,
					lastSeenAt: now,
				}))
			)
			.onConflictDoNothing();

		// Bulk update occurrences for existing items (single query instead of N queries)
		const existingHashes = items.filter((i) => existingSet.has(i.hash)).map((i) => i.hash);
		if (existingHashes.length > 0) {
			await this.db
				.update(this.sources)
				.set({
					occurrences: sql`${this.sources.occurrences} + 1`,
					lastSeenAt: now,
				})
				.where(inArray(this.sources.hash, existingHashes));
		}
	}

	/**
	 * Save a single translation
	 */
	async saveTranslation(
		locale: string,
		hash: string,
		text: string,
		options?: {
			sourceText?: string;
			context?: string;
			autoGenerated?: boolean;
		}
	): Promise<void> {
		const now = new Date();

		// Upsert translation
		await this.db
			.insert(this.translations)
			.values({
				locale,
				hash,
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
				createdAt: now,
				updatedAt: now,
			})
			.onConflictDoUpdate({
				target: [this.translations.locale, this.translations.hash],
				set: {
					text,
					autoGenerated: options?.autoGenerated ?? false,
					updatedAt: now,
				},
			});

		// If sourceText provided, ensure source exists
		if (options?.sourceText) {
			await this.registerSources([{ text: options.sourceText, hash, context: options.context }]);
		}
	}

	/**
	 * Get all source strings
	 */
	async getSources(): Promise<SourceString[]> {
		const results = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
				occurrences: this.sources.occurrences,
				lastSeenAt: this.sources.lastSeenAt,
			})
			.from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get untranslated strings for a locale
	 */
	async getUntranslated(locale: string): Promise<SourceString[]> {
		// Get hashes that have translations for this locale
		const translatedResults = (await this.db
			.select({
				hash: this.translations.hash,
			})
			.from(this.translations)
			.where(eq(this.translations.locale, locale))) as Array<{
			hash: string;
		}>;

		const translatedHashes = translatedResults.map((r) => r.hash);

		// Get sources that don't have translations
		const whereCondition =
			translatedHashes.length > 0
				? notInArray(this.sources.hash, translatedHashes)
				: undefined;

		const results = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
				occurrences: this.sources.occurrences,
				lastSeenAt: this.sources.lastSeenAt,
			})
			.from(this.sources)
			.where(whereCondition)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
			occurrences: number;
			lastSeenAt: Date;
		}>;

		return results.map((row) => ({
			id: row.id,
			hash: row.hash,
			text: row.text,
			context: row.context,
			occurrences: row.occurrences,
			lastSeenAt: row.lastSeenAt,
		}));
	}

	/**
	 * Get all locales that have at least one translation
	 */
	async getAvailableLocales(): Promise<string[]> {
		// SELECT DISTINCT locale FROM translations
		const results = (await this.db
			.select({
				locale: this.translations.locale,
			})
			.from(this.translations)
			.groupBy(this.translations.locale)) as Array<{ locale: string }>;

		return results.map((r) => r.locale);
	}

	// ============================================
	// Admin Methods
	// ============================================

	/**
	 * Get all source strings with their translation status for given locales
	 */
	async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
		// Get all sources
		const allSources = (await this.db
			.select({
				id: this.sources.id,
				hash: this.sources.hash,
				text: this.sources.text,
				context: this.sources.context,
			})
			.from(this.sources)) as Array<{
			id: number;
			hash: string;
			text: string;
			context: string | null;
		}>;

		// Get all translations for requested locales
		const allTranslations = (await this.db
			.select({
				hash: this.translations.hash,
				locale: this.translations.locale,
				text: this.translations.text,
				autoGenerated: this.translations.autoGenerated,
				reviewed: this.translations.reviewed,
			})
			.from(this.translations)
			.where(inArray(this.translations.locale, locales))) as Array<{
			hash: string;
			locale: string;
			text: string;
			autoGenerated: boolean;
			reviewed: boolean;
		}>;

		// Build lookup map: hash -> locale -> translation
		const translationMap = new Map<
			string,
			Map<string, { text: string; autoGenerated: boolean; reviewed: boolean }>
		>();
		for (const t of allTranslations) {
			if (!translationMap.has(t.hash)) {
				translationMap.set(t.hash, new Map());
			}
			translationMap.get(t.hash)!.set(t.locale, {
				text: t.text,
				autoGenerated: t.autoGenerated,
				reviewed: t.reviewed,
			});
		}

		// Build result
		return allSources.map((source) => {
			const sourceTranslations = translationMap.get(source.hash);
			const translationsResult: Record<
				string,
				{ text: string | null; autoGenerated: boolean; reviewed: boolean } | null
			> = {};

			for (const locale of locales) {
				const t = sourceTranslations?.get(locale);
				translationsResult[locale] = t
					? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed }
					: null;
			}

			return {
				id: source.id,
				hash: source.hash,
				text: source.text,
				context: source.context,
				translations: translationsResult,
			};
		});
	}

	/**
	 * Mark a translation as reviewed
	 */
	async markAsReviewed(locale: string, hash: string): Promise<void> {
		await this.db
			.update(this.translations)
			.set({ reviewed: true, updatedAt: new Date() })
			.where(
				and(eq(this.translations.locale, locale), eq(this.translations.hash, hash))
			);
	}

	/**
	 * Save multiple translations at once (bulk upsert for performance)
	 * Uses a single INSERT ... ON CONFLICT UPDATE query instead of N queries
	 */
	async saveTranslations(
		locale: string,
		items: Array<{
			hash: string;
			text: string;
			sourceText?: string;
			autoGenerated?: boolean;
		}>
	): Promise<void> {
		if (items.length === 0) return;

		const now = new Date();

		// Bulk upsert translations (single query)
		await this.db
			.insert(this.translations)
			.values(
				items.map((item) => ({
					locale,
					hash: item.hash,
					text: item.text,
					autoGenerated: item.autoGenerated ?? false,
					reviewed: false,
					createdAt: now,
					updatedAt: now,
				}))
			)
			.onConflictDoUpdate({
				target: [this.translations.locale, this.translations.hash],
				set: {
					text: sql`excluded.text`,
					autoGenerated: sql`excluded.auto_generated`,
					updatedAt: now,
				},
			});

		// Register source strings if provided (batch)
		const sourcesToRegister = items
			.filter((item) => item.sourceText)
			.map((item) => ({
				text: item.sourceText!,
				hash: item.hash,
			}));

		if (sourcesToRegister.length > 0) {
			await this.registerSources(sourcesToRegister);
		}
	}

	/**
	 * Delete a translation
	 */
	async deleteTranslation(locale: string, hash: string): Promise<void> {
		await this.db
			.delete(this.translations)
			.where(
				and(eq(this.translations.locale, locale), eq(this.translations.hash, hash))
			);
	}

	/**
	 * Delete a source string and all its translations
	 */
	async deleteSource(hash: string): Promise<void> {
		// Delete all translations for this hash
		await this.db
			.delete(this.translations)
			.where(eq(this.translations.hash, hash));

		// Delete source
		await this.db
			.delete(this.sources)
			.where(eq(this.sources.hash, hash));
	}
}

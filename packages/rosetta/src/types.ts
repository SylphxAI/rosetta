// ============================================
// Core Types
// ============================================

/**
 * Source string collected from production
 */
export interface SourceString {
	/** Unique identifier (from DB) */
	id?: string | number;
	/** Original text in source language */
	text: string;
	/** Hash for lookup */
	hash: string;
	/** Optional context for disambiguation */
	context?: string | null;
	/** Number of times this string was seen */
	occurrences?: number;
	/** Last time this string was encountered */
	lastSeenAt?: Date;
}

/**
 * Translation entry
 */
export interface Translation {
	hash: string;
	text: string;
	locale: string;
	autoGenerated?: boolean;
	reviewed?: boolean;
}

/**
 * Translation status for a specific locale
 */
export interface TranslationStatus {
	/** Translated text (null if not translated) */
	text: string | null;
	/** Whether this was auto-generated by AI */
	autoGenerated: boolean;
	/** Whether this has been reviewed by a human */
	reviewed: boolean;
	/** Hash of source text at translation time (8 char hex, for staleness detection) */
	sourceHash?: string | null;
	/** @deprecated Use sourceHash instead. Source text at time of translation */
	translatedFrom?: string | null;
}

/**
 * Source string with translation status for all locales
 * Used by admin dashboard
 */
export interface SourceWithStatus {
	/** Unique identifier */
	id: string | number;
	/** Original text in source language */
	text: string;
	/** Hash for lookup */
	hash: string;
	/** Optional context for disambiguation */
	context?: string | null;
	/** Translation status per locale */
	translations: Record<string, TranslationStatus | null>;
}

/**
 * Translation statistics
 */
export interface TranslationStats {
	/** Total number of source strings */
	totalStrings: number;
	/** Stats per locale */
	locales: Record<
		string,
		{
			/** Number of translated strings */
			translated: number;
			/** Number of reviewed strings */
			reviewed: number;
			/** Total strings (same as totalStrings) */
			total: number;
		}
	>;
}

/**
 * Locale information
 */
export interface LocaleInfo {
	code: string;
	name: string;
	nativeName: string;
}

// ============================================
// Adapter Interfaces
// ============================================

/**
 * Storage adapter for translations
 * Implement this interface for different storage backends (DB, file, API, etc.)
 */
export interface StorageAdapter {
	// ==================== Core Methods ====================

	/**
	 * Get all translations for a locale
	 * @returns Map of hash -> translated text
	 */
	getTranslations(locale: string): Promise<Map<string, string>>;

	/**
	 * Save a single translation
	 */
	saveTranslation(
		locale: string,
		hash: string,
		text: string,
		options?: {
			sourceText?: string;
			context?: string;
			autoGenerated?: boolean;
			/** Hash of source text at translation time (8 char hex, for staleness detection) */
			sourceHash?: string;
			/** @deprecated Use sourceHash instead. Source text at time of translation */
			translatedFrom?: string;
		}
	): Promise<void>;

	/**
	 * Get all source strings
	 */
	getSources(): Promise<SourceString[]>;

	/**
	 * Get untranslated strings for a locale
	 */
	getUntranslated(locale: string): Promise<SourceString[]>;

	/**
	 * Get all locales that have at least one translation
	 */
	getAvailableLocales(): Promise<string[]>;

	// ==================== Optimization Methods (Optional) ====================

	/**
	 * Get translations for specific hashes only (fine-grained loading)
	 * If not implemented, falls back to getTranslations() which loads all
	 * @returns Map of hash -> translated text (only for requested hashes)
	 */
	getTranslationsByHashes?(locale: string, hashes: string[]): Promise<Map<string, string>>;

	// ==================== Admin Methods (Optional) ====================

	/**
	 * Get all source strings with their translation status for given locales
	 * Used by admin dashboard
	 */
	getSourcesWithTranslations?(locales: string[]): Promise<SourceWithStatus[]>;

	/**
	 * Mark a translation as reviewed
	 */
	markAsReviewed?(locale: string, hash: string): Promise<void>;

	/**
	 * Save multiple translations at once (batch)
	 */
	saveTranslations?(
		locale: string,
		translations: Array<{
			hash: string;
			text: string;
			sourceText?: string;
			autoGenerated?: boolean;
			/** Hash of source text at translation time (8 char hex, for staleness detection) */
			sourceHash?: string;
			/** @deprecated Use sourceHash instead. Source text at time of translation */
			translatedFrom?: string;
		}>
	): Promise<void>;

	/**
	 * Delete a translation
	 */
	deleteTranslation?(locale: string, hash: string): Promise<void>;

	/**
	 * Delete a source string and all its translations
	 */
	deleteSource?(hash: string): Promise<void>;
}

/**
 * Cache adapter interface for translation caching
 */
export interface CacheAdapter {
	/**
	 * Get cached translations for a locale
	 * @returns Map of hash -> text, or null if not cached
	 */
	get(locale: string): Promise<Map<string, string> | null>;

	/**
	 * Set translations for a locale
	 */
	set(locale: string, translations: Map<string, string>): Promise<void>;

	/**
	 * Invalidate cache for a locale (or all if locale not specified)
	 */
	invalidate(locale?: string): Promise<void>;

	/**
	 * Check if cache has entry for locale
	 */
	has(locale: string): Promise<boolean>;
}

/**
 * Translation adapter for auto-generating translations
 * Implement this interface for different translation services (LLM, API, etc.)
 */
export interface TranslateAdapter {
	/**
	 * Translate a single text
	 */
	translate(
		text: string,
		options: {
			from: string;
			to: string;
			context?: string;
		}
	): Promise<string>;

	/**
	 * Translate multiple texts at once (optional, for efficiency)
	 */
	translateBatch?(
		texts: Array<{ text: string; context?: string }>,
		options: {
			from: string;
			to: string;
		}
	): Promise<string[]>;
}

// ============================================
// Context Types
// ============================================

/**
 * Pending source string to be registered
 */
export interface PendingSourceString {
	text: string;
	hash: string;
	context?: string;
}

/**
 * Rosetta context stored in AsyncLocalStorage
 */
export interface RosettaContext {
	/** Current locale */
	locale: string;
	/** Default/source locale */
	defaultLocale: string;
	/** Locale fallback chain (e.g., ['zh-TW', 'zh', 'en']) */
	localeChain: string[];
	/** hash -> translated text (merged from fallback chain) */
	translations: Map<string, string>;
	/** Storage adapter (for admin operations) */
	storage?: StorageAdapter;
	/** Whether context is fully initialized */
	initialized: boolean;
}

/**
 * Translation options with explicit params
 */
export interface TranslateOptions {
	/** Context for disambiguation (e.g., "button", "menu") */
	context?: string;
	/** Interpolation params for variables like {name} */
	params?: Record<string, string | number>;
}

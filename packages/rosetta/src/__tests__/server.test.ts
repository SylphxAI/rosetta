import { beforeEach, describe, expect, test } from 'bun:test';
import {
	buildLocaleChain,
	getLocale,
	getLocaleChain,
	getTranslationsForClient,
	isValidLocale,
	runWithRosetta,
	t,
} from '../server/context';
import { Rosetta } from '../server/i18n';
import type { SourceWithStatus, StorageAdapter, TranslateAdapter } from '../types';

// Extended mock storage adapter with admin methods
interface TranslationData {
	text: string;
	autoGenerated: boolean;
	reviewed: boolean;
}

function createMockStorage(): StorageAdapter & {
	_getSources: () => Map<string, { text: string; hash: string; context?: string }>;
	_getTranslations: () => Map<string, Map<string, TranslationData>>;
	_insertSource: (hash: string, text: string, context?: string) => void;
} {
	const sources = new Map<string, { text: string; hash: string; context?: string }>();
	const translations = new Map<string, Map<string, TranslationData>>();

	return {
		_getSources: () => sources,
		_getTranslations: () => translations,
		_insertSource: (hash: string, text: string, context?: string) => {
			sources.set(hash, { hash, text, context });
		},

		async getTranslations(locale: string) {
			const localeData = translations.get(locale) ?? new Map();
			const result = new Map<string, string>();
			for (const [hash, data] of localeData) {
				result.set(hash, data.text);
			}
			return result;
		},

		async saveTranslation(locale, hash, text, options) {
			if (!translations.has(locale)) {
				translations.set(locale, new Map());
			}
			translations.get(locale)!.set(hash, {
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
			});
		},

		async getSources() {
			return Array.from(sources.values()).map((s) => ({
				text: s.text,
				hash: s.hash,
				context: s.context,
			}));
		},

		async getUntranslated(locale) {
			const localeTranslations = translations.get(locale) ?? new Map();
			return Array.from(sources.values())
				.filter((s) => !localeTranslations.has(s.hash))
				.map((s) => ({
					text: s.text,
					hash: s.hash,
					context: s.context,
				}));
		},

		// Admin methods
		async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
			return Array.from(sources.values()).map((source) => {
				const translationsResult: Record<
					string,
					{ text: string | null; autoGenerated: boolean; reviewed: boolean } | null
				> = {};
				for (const locale of locales) {
					const localeData = translations.get(locale);
					const t = localeData?.get(source.hash);
					translationsResult[locale] = t
						? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed }
						: null;
				}
				return {
					id: source.hash,
					text: source.text,
					hash: source.hash,
					context: source.context,
					translations: translationsResult,
				};
			});
		},

		async markAsReviewed(locale: string, hash: string) {
			const localeData = translations.get(locale);
			if (localeData?.has(hash)) {
				const data = localeData.get(hash)!;
				localeData.set(hash, { ...data, reviewed: true });
			}
		},

		async deleteTranslation(locale: string, hash: string) {
			translations.get(locale)?.delete(hash);
		},

		async deleteSource(hash: string) {
			sources.delete(hash);
			for (const localeData of translations.values()) {
				localeData.delete(hash);
			}
		},

		async getAvailableLocales() {
			return Array.from(translations.keys());
		},
	};
}

// Mock translator adapter
function createMockTranslator(): TranslateAdapter {
	return {
		async translate(text, options) {
			// Simple mock: just append locale to text
			return `[${options.to}] ${text}`;
		},

		async translateBatch(texts, options) {
			return texts.map((item) => `[${options.to}] ${item.text}`);
		},
	};
}

describe('Rosetta class', () => {
	let storage: StorageAdapter;
	let rosetta: Rosetta;

	beforeEach(() => {
		storage = createMockStorage();
		rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});
	});

	test('init() sets up context correctly', async () => {
		let capturedLocale: string | undefined;

		await rosetta.init(() => {
			capturedLocale = getLocale();
		});

		expect(capturedLocale).toBe('en');
	});

	test('init() uses locale detector', async () => {
		rosetta.setLocaleDetector(() => 'zh-TW');

		let capturedLocale: string | undefined;
		await rosetta.init(() => {
			capturedLocale = getLocale();
		});

		expect(capturedLocale).toBe('zh-TW');
	});

	test('getAvailableLocales() returns locales from DB', async () => {
		// Add some translations first
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('ja', 'hash1', 'こんにちは');

		const locales = await rosetta.getAvailableLocales();
		expect(locales).toContain('zh-TW');
		expect(locales).toContain('ja');
	});

	test('getDefaultLocale() returns correct locale', () => {
		expect(rosetta.getDefaultLocale()).toBe('en');
	});
});

describe('t() function', () => {
	test('returns source text when no context', () => {
		const result = t('Hello World');
		expect(result).toBe('Hello World');
	});

	test('interpolates parameters', () => {
		const result = t('Hello {name}', { name: 'World' });
		expect(result).toBe('Hello World');
	});

	test('returns source text for default locale', async () => {
		const storage = createMockStorage();
		const rosetta = new Rosetta({ storage, defaultLocale: 'en' });

		let result: string | undefined;
		await rosetta.init(() => {
			result = t('Hello World');
		});

		expect(result).toBe('Hello World');
	});

	test('returns translated text for non-default locale', async () => {
		const storage = createMockStorage();
		await storage.saveTranslation('zh-TW', '35ddf285', '你好世界'); // hash of "Hello World"

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
			localeDetector: () => 'zh-TW',
		});

		let result: string | undefined;
		await rosetta.init(() => {
			result = t('Hello World');
		});

		expect(result).toBe('你好世界');
	});
});

describe('runWithRosetta', () => {
	test('provides context to nested function', () => {
		const translations = new Map([['abc123', '翻譯']]);

		let capturedLocale: string | undefined;
		runWithRosetta(
			{
				locale: 'zh-TW',
				defaultLocale: 'en',
				translations,
			},
			() => {
				capturedLocale = getLocale();
			}
		);

		expect(capturedLocale).toBe('zh-TW');
	});
});

describe('getTranslationsForClient', () => {
	test('returns empty object when no context', () => {
		expect(getTranslationsForClient()).toEqual({});
	});

	test('returns translations from context', () => {
		const translations = new Map([['hash123', '你好世界']]);

		let result: Record<string, string> | undefined;
		runWithRosetta(
			{
				locale: 'zh-TW',
				defaultLocale: 'en',
				translations,
			},
			() => {
				result = getTranslationsForClient();
			}
		);

		expect(result).toEqual({ hash123: '你好世界' });
	});
});

// ============================================
// Admin Methods Tests
// ============================================

describe('Rosetta admin methods', () => {
	test('getSourcesWithStatus() returns sources with translation status', async () => {
		const storage = createMockStorage();
		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		await storage.saveTranslation('zh-TW', 'hash1', '你好', { autoGenerated: true });

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const result = await rosetta.getSourcesWithStatus(['zh-TW']);

		expect(result).toHaveLength(2);
		expect(result[0]?.translations['zh-TW']).toEqual({
			text: '你好',
			autoGenerated: true,
			reviewed: false,
		});
		expect(result[1]?.translations['zh-TW']).toBeNull();
	});

	test('getTranslationStats() returns correct statistics', async () => {
		const storage = createMockStorage();
		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		storage._insertSource('hash3', 'Test');
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const stats = await rosetta.getTranslationStats(['zh-TW']);

		expect(stats.totalStrings).toBe(3);
		expect(stats.locales['zh-TW']).toEqual({
			translated: 2,
			reviewed: 0,
			total: 3,
		});
	});

	test('markAsReviewed() marks translation as reviewed', async () => {
		const storage = createMockStorage();
		storage._insertSource('hash1', 'Hello');
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		await rosetta.markAsReviewed('hash1', 'zh-TW');

		const sources = await rosetta.getSourcesWithStatus(['zh-TW']);
		expect(sources[0]?.translations['zh-TW']?.reviewed).toBe(true);
	});

	test('exportTranslations() exports source->translation map', async () => {
		const storage = createMockStorage();
		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const exported = await rosetta.exportTranslations('zh-TW');

		expect(exported).toEqual({
			Hello: '你好',
			World: '世界',
		});
	});

	test('importTranslations() imports translations from JSON', async () => {
		const storage = createMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const count = await rosetta.importTranslations('zh-TW', {
			Hello: '你好',
			World: '世界',
		});

		expect(count).toBe(2);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});

	test('saveTranslationByHash() saves translation directly', async () => {
		const storage = createMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		await rosetta.saveTranslationByHash('zh-TW', 'hash1', '你好', { autoGenerated: false });

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.get('hash1')).toBe('你好');
	});
});

describe('Rosetta translation generation', () => {
	test('generateTranslation() uses translator adapter', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.generateTranslation('Hello', 'zh-TW');
		expect(result).toBe('[zh-TW] Hello');
	});

	test('generateTranslation() returns source for default locale', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.generateTranslation('Hello', 'en');
		expect(result).toBe('Hello');
	});

	test('generateTranslation() throws without translator', async () => {
		const storage = createMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		await expect(rosetta.generateTranslation('Hello', 'zh-TW')).rejects.toThrow(
			'No translator adapter configured'
		);
	});

	test('generateAndSave() generates and saves translation', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.generateAndSave('Hello', 'zh-TW');
		expect(result).toBe('[zh-TW] Hello');

		// Verify it was saved
		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(1);
	});

	test('batchTranslate() translates multiple strings', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.batchTranslate(
			[
				{ hash: 'hash1', text: 'Hello' },
				{ hash: 'hash2', text: 'World' },
			],
			'zh-TW'
		);

		expect(result.success).toBe(2);
		expect(result.failed).toBe(0);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});

	test('batchTranslate() returns empty result for empty array', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.batchTranslate([], 'zh-TW');

		expect(result.success).toBe(0);
		expect(result.failed).toBe(0);
	});

	test('generateAllUntranslated() translates all missing strings', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		storage._insertSource('hash1', 'Hello');
		storage._insertSource('hash2', 'World');
		// Only translate one
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const rosetta = new Rosetta({
			storage,
			translator,
			defaultLocale: 'en',
		});

		const result = await rosetta.generateAllUntranslated('zh-TW');

		expect(result.success).toBe(1);
		expect(result.failed).toBe(0);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});
});

// ============================================
// Locale Utilities Tests
// ============================================

describe('buildLocaleChain', () => {
	test('returns chain for simple locale', () => {
		const chain = buildLocaleChain('ja', 'en');
		expect(chain).toEqual(['ja', 'en']);
	});

	test('returns chain with parent for regional locale', () => {
		const chain = buildLocaleChain('zh-TW', 'en');
		expect(chain).toEqual(['zh-TW', 'zh', 'en']);
	});

	test('returns chain for pt-BR', () => {
		const chain = buildLocaleChain('pt-BR', 'en');
		expect(chain).toEqual(['pt-BR', 'pt', 'en']);
	});

	test('avoids duplicate when default is in chain', () => {
		const chain = buildLocaleChain('en-US', 'en');
		expect(chain).toEqual(['en-US', 'en']);
	});

	test('handles same locale as default', () => {
		const chain = buildLocaleChain('en', 'en');
		expect(chain).toEqual(['en']);
	});
});

describe('isValidLocale', () => {
	test('validates simple locale codes', () => {
		expect(isValidLocale('en')).toBe(true);
		expect(isValidLocale('ja')).toBe(true);
		expect(isValidLocale('zh')).toBe(true);
	});

	test('validates regional locale codes', () => {
		expect(isValidLocale('zh-TW')).toBe(true);
		expect(isValidLocale('pt-BR')).toBe(true);
		expect(isValidLocale('en-US')).toBe(true);
	});

	test('validates script locale codes', () => {
		expect(isValidLocale('zh-hans')).toBe(true);
		expect(isValidLocale('zh-hant')).toBe(true);
	});

	test('rejects invalid formats', () => {
		expect(isValidLocale('')).toBe(false);
		expect(isValidLocale('e')).toBe(false);
		expect(isValidLocale('eng')).toBe(false);
		expect(isValidLocale('en_US')).toBe(false);
		expect(isValidLocale('en-usa')).toBe(false);
	});
});

describe('getLocaleChain', () => {
	test('returns default chain when no context', () => {
		expect(getLocaleChain()).toEqual(['en']);
	});

	test('returns chain from context', () => {
		const translations = new Map();
		let result: string[] = [];

		runWithRosetta(
			{
				locale: 'zh-TW',
				defaultLocale: 'en',
				localeChain: ['zh-TW', 'zh', 'en'],
				translations,
			},
			() => {
				result = getLocaleChain();
			}
		);

		expect(result).toEqual(['zh-TW', 'zh', 'en']);
	});
});

// ============================================
// ICU MessageFormat Tests
// ============================================

describe('t() with ICU MessageFormat', () => {
	test('handles simple plural', () => {
		const result = t('{count, plural, one {# item} other {# items}}', { count: 1 });
		expect(result).toBe('1 item');
	});

	test('handles plural with multiple items', () => {
		const result = t('{count, plural, one {# item} other {# items}}', { count: 5 });
		expect(result).toBe('5 items');
	});

	test('handles plural with zero', () => {
		const result = t('{count, plural, =0 {No items} one {# item} other {# items}}', { count: 0 });
		expect(result).toBe('No items');
	});

	test('handles select for gender', () => {
		const result = t('{gender, select, male {He} female {She} other {They}}', { gender: 'female' });
		expect(result).toBe('She');
	});

	test('handles select with other fallback', () => {
		const result = t('{gender, select, male {He} female {She} other {They}}', {
			gender: 'unknown',
		});
		expect(result).toBe('They');
	});

	test('handles mixed ICU and interpolation', () => {
		const translations = new Map();
		let result = '';

		runWithRosetta(
			{
				locale: 'en',
				defaultLocale: 'en',
				translations,
			},
			() => {
				result = t('{count, plural, one {# item} other {# items}} in cart', { count: 3 });
			}
		);

		expect(result).toBe('3 items in cart');
	});
});

// ============================================
// Locale Fallback Chain Loading Tests
// ============================================

describe('Rosetta locale fallback chain', () => {
	test('loadTranslations() merges from fallback chain', async () => {
		const storage = createMockStorage();

		// zh has some translations
		await storage.saveTranslation('zh', 'hash1', '你好');
		await storage.saveTranslation('zh', 'hash2', '世界');

		// zh-TW overrides hash1 only
		await storage.saveTranslation('zh-TW', 'hash1', '你好 (台灣)');

		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const translations = await rosetta.loadTranslations('zh-TW');

		// hash1 should be overridden by zh-TW
		expect(translations.get('hash1')).toBe('你好 (台灣)');
		// hash2 should fall back to zh
		expect(translations.get('hash2')).toBe('世界');
	});

	test('loadTranslations() returns empty map for default locale', async () => {
		const storage = createMockStorage();
		const rosetta = new Rosetta({
			storage,
			defaultLocale: 'en',
		});

		const translations = await rosetta.loadTranslations('en');
		expect(translations.size).toBe(0);
	});
});

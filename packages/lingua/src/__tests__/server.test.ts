import { describe, expect, test, beforeEach, mock } from 'bun:test';
import { I18n } from '../server/i18n';
import {
	t,
	getLocale,
	flushCollectedStrings,
	runWithI18n,
	getTranslationsForClient,
} from '../server/context';
import type { StorageAdapter, SourceWithStatus, TranslateAdapter } from '../types';

// Extended mock storage adapter with admin methods
interface TranslationData {
	text: string;
	autoGenerated: boolean;
	reviewed: boolean;
}

function createMockStorage(): StorageAdapter & {
	_getSources: () => Map<string, { text: string; hash: string; context?: string }>;
	_getTranslations: () => Map<string, Map<string, TranslationData>>;
} {
	const sources = new Map<string, { text: string; hash: string; context?: string }>();
	const translations = new Map<string, Map<string, TranslationData>>();

	return {
		_getSources: () => sources,
		_getTranslations: () => translations,

		async getTranslations(locale: string) {
			const localeData = translations.get(locale) ?? new Map();
			const result = new Map<string, string>();
			for (const [hash, data] of localeData) {
				result.set(hash, data.text);
			}
			return result;
		},

		async registerSources(items) {
			for (const item of items) {
				sources.set(item.hash, item);
			}
		},

		async saveTranslation(locale, hash, text, options) {
			if (!translations.has(locale)) {
				translations.set(locale, new Map());
			}
			translations.get(locale)!.set(hash, {
				text,
				autoGenerated: options?.autoGenerated ?? false,
				reviewed: false,
			});
		},

		async getSources() {
			return Array.from(sources.values()).map((s) => ({
				text: s.text,
				hash: s.hash,
				context: s.context,
			}));
		},

		async getUntranslated(locale) {
			const localeTranslations = translations.get(locale) ?? new Map();
			return Array.from(sources.values())
				.filter((s) => !localeTranslations.has(s.hash))
				.map((s) => ({
					text: s.text,
					hash: s.hash,
					context: s.context,
				}));
		},

		// Admin methods
		async getSourcesWithTranslations(locales: string[]): Promise<SourceWithStatus[]> {
			return Array.from(sources.values()).map((source) => {
				const translationsResult: Record<string, { text: string | null; autoGenerated: boolean; reviewed: boolean } | null> = {};
				for (const locale of locales) {
					const localeData = translations.get(locale);
					const t = localeData?.get(source.hash);
					translationsResult[locale] = t ? { text: t.text, autoGenerated: t.autoGenerated, reviewed: t.reviewed } : null;
				}
				return {
					id: source.hash,
					text: source.text,
					hash: source.hash,
					context: source.context,
					translations: translationsResult,
				};
			});
		},

		async markAsReviewed(locale: string, hash: string) {
			const localeData = translations.get(locale);
			if (localeData?.has(hash)) {
				const data = localeData.get(hash)!;
				localeData.set(hash, { ...data, reviewed: true });
			}
		},

		async deleteTranslation(locale: string, hash: string) {
			translations.get(locale)?.delete(hash);
		},

		async deleteSource(hash: string) {
			sources.delete(hash);
			for (const localeData of translations.values()) {
				localeData.delete(hash);
			}
		},
	};
}

// Mock translator adapter
function createMockTranslator(): TranslateAdapter {
	return {
		async translate(text, options) {
			// Simple mock: just append locale to text
			return `[${options.to}] ${text}`;
		},

		async translateBatch(texts, options) {
			return texts.map((item) => `[${options.to}] ${item.text}`);
		},
	};
}

describe('I18n class', () => {
	let storage: StorageAdapter;
	let i18n: I18n;

	beforeEach(() => {
		storage = createMockStorage();
		i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});
	});

	test('init() sets up context correctly', async () => {
		let capturedLocale: string | undefined;

		await i18n.init(() => {
			capturedLocale = getLocale();
		});

		expect(capturedLocale).toBe('en');
	});

	test('init() uses locale detector', async () => {
		i18n.setLocaleDetector(() => 'zh-TW');

		let capturedLocale: string | undefined;
		await i18n.init(() => {
			capturedLocale = getLocale();
		});

		expect(capturedLocale).toBe('zh-TW');
	});

	test('getEnabledLocales() returns correct locales', () => {
		expect(i18n.getEnabledLocales()).toEqual(['en', 'zh-TW']);
	});

	test('getDefaultLocale() returns correct locale', () => {
		expect(i18n.getDefaultLocale()).toBe('en');
	});
});

describe('t() function', () => {
	test('returns source text when no context', () => {
		const result = t('Hello World');
		expect(result).toBe('Hello World');
	});

	test('interpolates parameters', () => {
		const result = t('Hello {name}', { name: 'World' });
		expect(result).toBe('Hello World');
	});

	test('returns source text for default locale', async () => {
		const storage = createMockStorage();
		const i18n = new I18n({ storage, defaultLocale: 'en' });

		let result: string | undefined;
		await i18n.init(() => {
			result = t('Hello World');
		});

		expect(result).toBe('Hello World');
	});

	test('returns translated text for non-default locale', async () => {
		const storage = createMockStorage();
		await storage.saveTranslation('zh-TW', '35ddf285', '你好世界'); // hash of "Hello World"

		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
			localeDetector: () => 'zh-TW',
		});

		let result: string | undefined;
		await i18n.init(() => {
			result = t('Hello World');
		});

		expect(result).toBe('你好世界');
	});
});

describe('runWithI18n', () => {
	test('provides context to nested function', () => {
		const translations = new Map([['abc123', '翻譯']]);

		let capturedLocale: string | undefined;
		runWithI18n(
			{
				locale: 'zh-TW',
				defaultLocale: 'en',
				translations,
				translationsForClient: {},
			},
			() => {
				capturedLocale = getLocale();
			}
		);

		expect(capturedLocale).toBe('zh-TW');
	});
});

describe('getTranslationsForClient', () => {
	test('returns empty object when no context', () => {
		expect(getTranslationsForClient()).toEqual({});
	});

	test('returns translations from context', () => {
		const translationsForClient = { 'Hello World': '你好世界' };

		let result: Record<string, string> | undefined;
		runWithI18n(
			{
				locale: 'zh-TW',
				defaultLocale: 'en',
				translations: new Map(),
				translationsForClient,
			},
			() => {
				result = getTranslationsForClient();
			}
		);

		expect(result).toEqual(translationsForClient);
	});
});

// ============================================
// Admin Methods Tests
// ============================================

describe('I18n admin methods', () => {
	test('getTargetLocales() excludes default locale', () => {
		const storage = createMockStorage();
		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW', 'ja'],
		});

		expect(i18n.getTargetLocales()).toEqual(['zh-TW', 'ja']);
	});

	test('getSourcesWithStatus() returns sources with translation status', async () => {
		const storage = createMockStorage();
		await storage.registerSources([
			{ text: 'Hello', hash: 'hash1' },
			{ text: 'World', hash: 'hash2' },
		]);
		await storage.saveTranslation('zh-TW', 'hash1', '你好', { autoGenerated: true });

		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.getSourcesWithStatus();

		expect(result).toHaveLength(2);
		expect(result[0]?.translations['zh-TW']).toEqual({
			text: '你好',
			autoGenerated: true,
			reviewed: false,
		});
		expect(result[1]?.translations['zh-TW']).toBeNull();
	});

	test('getStats() returns correct statistics', async () => {
		const storage = createMockStorage();
		await storage.registerSources([
			{ text: 'Hello', hash: 'hash1' },
			{ text: 'World', hash: 'hash2' },
			{ text: 'Test', hash: 'hash3' },
		]);
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');

		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const stats = await i18n.getStats();

		expect(stats.totalStrings).toBe(3);
		expect(stats.locales['zh-TW']).toEqual({
			translated: 2,
			reviewed: 0,
			total: 3,
		});
	});

	test('markAsReviewed() marks translation as reviewed', async () => {
		const storage = createMockStorage();
		await storage.registerSources([{ text: 'Hello', hash: 'hash1' }]);
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		await i18n.markAsReviewed('hash1', 'zh-TW');

		const sources = await i18n.getSourcesWithStatus();
		expect(sources[0]?.translations['zh-TW']?.reviewed).toBe(true);
	});

	test('exportTranslations() exports source->translation map', async () => {
		const storage = createMockStorage();
		await storage.registerSources([
			{ text: 'Hello', hash: 'hash1' },
			{ text: 'World', hash: 'hash2' },
		]);
		await storage.saveTranslation('zh-TW', 'hash1', '你好');
		await storage.saveTranslation('zh-TW', 'hash2', '世界');

		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const exported = await i18n.exportTranslations('zh-TW');

		expect(exported).toEqual({
			Hello: '你好',
			World: '世界',
		});
	});

	test('importTranslations() imports translations from JSON', async () => {
		const storage = createMockStorage();
		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const count = await i18n.importTranslations('zh-TW', {
			Hello: '你好',
			World: '世界',
		});

		expect(count).toBe(2);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});

	test('saveTranslationByHash() saves translation directly', async () => {
		const storage = createMockStorage();
		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		await i18n.saveTranslationByHash('zh-TW', 'hash1', '你好', { autoGenerated: false });

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.get('hash1')).toBe('你好');
	});
});

describe('I18n translation generation', () => {
	test('generateTranslation() uses translator adapter', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.generateTranslation('Hello', 'zh-TW');
		expect(result).toBe('[zh-TW] Hello');
	});

	test('generateTranslation() returns source for default locale', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.generateTranslation('Hello', 'en');
		expect(result).toBe('Hello');
	});

	test('generateTranslation() throws without translator', async () => {
		const storage = createMockStorage();
		const i18n = new I18n({
			storage,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		await expect(i18n.generateTranslation('Hello', 'zh-TW')).rejects.toThrow(
			'No translator adapter configured'
		);
	});

	test('generateAndSave() generates and saves translation', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.generateAndSave('Hello', 'zh-TW');
		expect(result).toBe('[zh-TW] Hello');

		// Verify it was saved
		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(1);
	});

	test('batchTranslate() translates multiple strings', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.batchTranslate(
			[
				{ hash: 'hash1', text: 'Hello' },
				{ hash: 'hash2', text: 'World' },
			],
			'zh-TW'
		);

		expect(result.success).toBe(2);
		expect(result.failed).toBe(0);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});

	test('batchTranslate() returns empty result for empty array', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.batchTranslate([], 'zh-TW');

		expect(result.success).toBe(0);
		expect(result.failed).toBe(0);
	});

	test('generateAllUntranslated() translates all missing strings', async () => {
		const storage = createMockStorage();
		const translator = createMockTranslator();

		await storage.registerSources([
			{ text: 'Hello', hash: 'hash1' },
			{ text: 'World', hash: 'hash2' },
		]);
		// Only translate one
		await storage.saveTranslation('zh-TW', 'hash1', '你好');

		const i18n = new I18n({
			storage,
			translator,
			defaultLocale: 'en',
			enabledLocales: ['en', 'zh-TW'],
		});

		const result = await i18n.generateAllUntranslated('zh-TW');

		expect(result.success).toBe(1);
		expect(result.failed).toBe(0);

		const translations = await storage.getTranslations('zh-TW');
		expect(translations.size).toBe(2);
	});
});

# Custom Storage Adapter

Implement your own storage backend for Rosetta.

## StorageAdapter Interface

```ts
interface StorageAdapter {
  // Required: Core operations
  getTranslations(locale: string): Promise<Map<string, string>>;
  saveTranslation(
    locale: string,
    hash: string,
    text: string,
    options?: SaveTranslationOptions
  ): Promise<void>;
  getSources(): Promise<SourceString[]>;
  getUntranslated(locale: string): Promise<SourceString[]>;
  getAvailableLocales(): Promise<string[]>;

  // Optional: Admin operations
  getSourcesWithTranslations?(
    locales: string[]
  ): Promise<SourceWithTranslations[]>;
  saveTranslations?(
    locale: string,
    translations: Map<string, string>
  ): Promise<void>;
  markAsReviewed?(locale: string, hash: string): Promise<void>;
}
```

## Types

```ts
interface SourceString {
  hash: string;
  text: string;
  context?: string | null;
}

interface SaveTranslationOptions {
  autoGenerated?: boolean;
  sourceHash?: string;       // 8-char hash for staleness detection
  translatedFrom?: string;   // Deprecated: full source text
}

interface SourceWithTranslations {
  hash: string;
  text: string;
  context?: string | null;
  translations: Record<string, {
    text: string | null;
    autoGenerated: boolean;
    reviewed: boolean;
    sourceHash?: string | null;
    translatedFrom?: string | null;
  } | null>;
}
```

## Example: In-Memory Adapter

```ts
import type { StorageAdapter, SourceString, SaveTranslationOptions } from '@sylphx/rosetta';

class InMemoryStorageAdapter implements StorageAdapter {
  private sources = new Map<string, SourceString>();
  private translations = new Map<string, Map<string, string>>();
  private metadata = new Map<string, Map<string, {
    autoGenerated: boolean;
    reviewed: boolean;
    sourceHash?: string;
  }>>();

  async getTranslations(locale: string): Promise<Map<string, string>> {
    return this.translations.get(locale) ?? new Map();
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string,
    options?: SaveTranslationOptions
  ): Promise<void> {
    // Get or create locale map
    let localeTranslations = this.translations.get(locale);
    if (!localeTranslations) {
      localeTranslations = new Map();
      this.translations.set(locale, localeTranslations);
    }
    localeTranslations.set(hash, text);

    // Store metadata
    let localeMeta = this.metadata.get(locale);
    if (!localeMeta) {
      localeMeta = new Map();
      this.metadata.set(locale, localeMeta);
    }
    localeMeta.set(hash, {
      autoGenerated: options?.autoGenerated ?? false,
      reviewed: false,
      sourceHash: options?.sourceHash,
    });
  }

  async getSources(): Promise<SourceString[]> {
    return Array.from(this.sources.values());
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    const translated = this.translations.get(locale) ?? new Map();
    return Array.from(this.sources.values())
      .filter(source => !translated.has(source.hash));
  }

  async getAvailableLocales(): Promise<string[]> {
    return Array.from(this.translations.keys());
  }

  // Admin method
  async markAsReviewed(locale: string, hash: string): Promise<void> {
    const localeMeta = this.metadata.get(locale);
    if (localeMeta) {
      const meta = localeMeta.get(hash);
      if (meta) {
        meta.reviewed = true;
      }
    }
  }

  // Helper to add source strings
  addSource(source: SourceString): void {
    this.sources.set(source.hash, source);
  }
}
```

## Example: File-Based Adapter

```ts
import { readFile, writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import type { StorageAdapter, SourceString } from '@sylphx/rosetta';

class FileStorageAdapter implements StorageAdapter {
  constructor(private baseDir: string) {}

  private getLocalePath(locale: string): string {
    return join(this.baseDir, `${locale}.json`);
  }

  private getSourcesPath(): string {
    return join(this.baseDir, 'sources.json');
  }

  async getTranslations(locale: string): Promise<Map<string, string>> {
    try {
      const content = await readFile(this.getLocalePath(locale), 'utf-8');
      const data = JSON.parse(content) as Record<string, string>;
      return new Map(Object.entries(data));
    } catch {
      return new Map();
    }
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string
  ): Promise<void> {
    const translations = await this.getTranslations(locale);
    translations.set(hash, text);

    await mkdir(this.baseDir, { recursive: true });
    await writeFile(
      this.getLocalePath(locale),
      JSON.stringify(Object.fromEntries(translations), null, 2)
    );
  }

  async getSources(): Promise<SourceString[]> {
    try {
      const content = await readFile(this.getSourcesPath(), 'utf-8');
      return JSON.parse(content);
    } catch {
      return [];
    }
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    const sources = await this.getSources();
    const translations = await this.getTranslations(locale);
    return sources.filter(s => !translations.has(s.hash));
  }

  async getAvailableLocales(): Promise<string[]> {
    const { readdir } = await import('fs/promises');
    try {
      const files = await readdir(this.baseDir);
      return files
        .filter(f => f.endsWith('.json') && f !== 'sources.json')
        .map(f => f.replace('.json', ''));
    } catch {
      return [];
    }
  }
}
```

## Example: Redis Adapter

```ts
import type { Redis } from '@upstash/redis';
import type { StorageAdapter, SourceString } from '@sylphx/rosetta';

class RedisStorageAdapter implements StorageAdapter {
  constructor(
    private redis: Redis,
    private prefix = 'rosetta:'
  ) {}

  private key(type: string, ...parts: string[]): string {
    return [this.prefix, type, ...parts].join(':');
  }

  async getTranslations(locale: string): Promise<Map<string, string>> {
    const data = await this.redis.hgetall(this.key('translations', locale));
    if (!data) return new Map();
    return new Map(Object.entries(data as Record<string, string>));
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string
  ): Promise<void> {
    await this.redis.hset(this.key('translations', locale), { [hash]: text });
  }

  async getSources(): Promise<SourceString[]> {
    const data = await this.redis.hgetall(this.key('sources'));
    if (!data) return [];
    return Object.entries(data).map(([hash, json]) => ({
      hash,
      ...JSON.parse(json as string),
    }));
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    const sources = await this.getSources();
    const translations = await this.getTranslations(locale);
    return sources.filter(s => !translations.has(s.hash));
  }

  async getAvailableLocales(): Promise<string[]> {
    const keys = await this.redis.keys(this.key('translations', '*'));
    return keys.map(k => k.split(':').pop()!);
  }
}
```

## Admin-Specific Methods

For full admin dashboard support, implement these optional methods:

### getSourcesWithTranslations

```ts
async getSourcesWithTranslations(
  locales: string[]
): Promise<SourceWithTranslations[]> {
  const sources = await this.getSources();

  return Promise.all(
    sources.map(async (source) => {
      const translations: Record<string, TranslationData | null> = {};

      for (const locale of locales) {
        const data = await this.getTranslationData(locale, source.hash);
        translations[locale] = data;
      }

      return {
        ...source,
        translations,
      };
    })
  );
}
```

### saveTranslations (batch)

```ts
async saveTranslations(
  locale: string,
  translations: Map<string, string>
): Promise<void> {
  // Batch insert/update
  const entries = Array.from(translations.entries());

  await Promise.all(
    entries.map(([hash, text]) =>
      this.saveTranslation(locale, hash, text)
    )
  );
}
```

### markAsReviewed

```ts
async markAsReviewed(locale: string, hash: string): Promise<void> {
  // Update reviewed flag in your storage
  await this.updateMetadata(locale, hash, { reviewed: true });
}
```

## Staleness Detection

When saving translations, store the source hash for staleness detection:

```ts
async saveTranslation(
  locale: string,
  hash: string,
  text: string,
  options?: SaveTranslationOptions
): Promise<void> {
  await this.db.insert(translations).values({
    locale,
    hash,
    text,
    autoGenerated: options?.autoGenerated ?? false,
    reviewed: false,
    sourceHash: options?.sourceHash,  // 8-char hash of source text
  }).onConflictDoUpdate({
    target: [translations.locale, translations.hash],
    set: {
      text,
      autoGenerated: options?.autoGenerated ?? false,
      reviewed: false,  // Reset on update
      sourceHash: options?.sourceHash,
      updatedAt: new Date(),
    },
  });
}
```

The admin UI compares `sourceHash` with the current source text hash to detect outdated translations.

## Performance Considerations

### Indexing

For database adapters, ensure these indexes:

```sql
CREATE INDEX idx_translations_locale ON translations(locale);
CREATE INDEX idx_translations_hash ON translations(hash);
CREATE UNIQUE INDEX idx_translations_locale_hash ON translations(locale, hash);
```

### Caching

Wrap your adapter with caching:

```ts
import { InMemoryCache } from '@sylphx/rosetta/server';

const cache = new InMemoryCache({ ttlMs: 60000 });

// In Rosetta initialization
const rosetta = new Rosetta({
  storage: myAdapter,
  cache,
});
```

### Batch Operations

Implement `saveTranslations` for efficient batch saves:

```ts
async saveTranslations(
  locale: string,
  translations: Map<string, string>
): Promise<void> {
  // Use bulk insert/upsert
  const values = Array.from(translations.entries()).map(([hash, text]) => ({
    locale,
    hash,
    text,
  }));

  await this.db.insert(translationsTable)
    .values(values)
    .onConflictDoUpdate(/* ... */);
}
```

## Testing Your Adapter

```ts
import { describe, it, expect } from 'bun:test';

describe('MyStorageAdapter', () => {
  const adapter = new MyStorageAdapter();

  it('should save and retrieve translations', async () => {
    await adapter.saveTranslation('en', 'abc123', 'Hello');

    const translations = await adapter.getTranslations('en');
    expect(translations.get('abc123')).toBe('Hello');
  });

  it('should list available locales', async () => {
    await adapter.saveTranslation('en', 'abc123', 'Hello');
    await adapter.saveTranslation('zh', 'abc123', '你好');

    const locales = await adapter.getAvailableLocales();
    expect(locales).toContain('en');
    expect(locales).toContain('zh');
  });

  it('should find untranslated strings', async () => {
    // Add source
    adapter.addSource({ hash: 'abc123', text: 'Hello' });
    adapter.addSource({ hash: 'def456', text: 'World' });

    // Translate only one
    await adapter.saveTranslation('zh', 'abc123', '你好');

    const untranslated = await adapter.getUntranslated('zh');
    expect(untranslated).toHaveLength(1);
    expect(untranslated[0].hash).toBe('def456');
  });
});
```

## Next Steps

- [Drizzle Adapter](/packages/rosetta-drizzle) - Reference implementation
- [Caching](/advanced/caching) - Add caching layer
- [Admin Dashboard](/packages/rosetta-admin) - Use with admin UI

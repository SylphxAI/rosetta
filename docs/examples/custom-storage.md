# Custom Storage Example

Build a custom storage adapter for Rosetta.

## Overview

This example shows how to create storage adapters for different backends:
- Prisma ORM
- MongoDB
- REST API

## StorageAdapter Interface

```ts
interface StorageAdapter {
  // Required
  getTranslations(locale: string): Promise<Map<string, string>>;
  saveTranslation(locale: string, hash: string, text: string, options?: SaveTranslationOptions): Promise<void>;
  getSources(): Promise<SourceString[]>;
  getUntranslated(locale: string): Promise<SourceString[]>;
  getAvailableLocales(): Promise<string[]>;

  // Optional (for admin)
  getSourcesWithTranslations?(locales: string[]): Promise<SourceWithTranslations[]>;
  saveTranslations?(locale: string, translations: Map<string, string>): Promise<void>;
  markAsReviewed?(locale: string, hash: string): Promise<void>;
}
```

## Example: Prisma Adapter

### Prisma Schema

```prisma
// prisma/schema.prisma
model RosettaSource {
  id          Int      @id @default(autoincrement())
  hash        String   @unique @db.VarChar(8)
  text        String
  context     String?
  occurrences Int      @default(1)
  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @default(now())

  @@map("rosetta_sources")
}

model RosettaTranslation {
  id            Int      @id @default(autoincrement())
  locale        String   @db.VarChar(10)
  hash          String   @db.VarChar(8)
  text          String
  sourceHash    String?  @db.VarChar(8)
  autoGenerated Boolean  @default(false)
  reviewed      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([locale, hash])
  @@index([locale])
  @@index([hash])
  @@map("rosetta_translations")
}
```

### Adapter Implementation

```ts
// lib/rosetta/prisma-adapter.ts
import { PrismaClient } from '@prisma/client';
import type {
  StorageAdapter,
  SourceString,
  SaveTranslationOptions,
  SourceWithTranslations,
} from '@sylphx/rosetta';

export class PrismaStorageAdapter implements StorageAdapter {
  constructor(private prisma: PrismaClient) {}

  async getTranslations(locale: string): Promise<Map<string, string>> {
    const translations = await this.prisma.rosettaTranslation.findMany({
      where: { locale },
      select: { hash: true, text: true },
    });

    return new Map(translations.map(t => [t.hash, t.text]));
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string,
    options?: SaveTranslationOptions
  ): Promise<void> {
    await this.prisma.rosettaTranslation.upsert({
      where: { locale_hash: { locale, hash } },
      create: {
        locale,
        hash,
        text,
        autoGenerated: options?.autoGenerated ?? false,
        sourceHash: options?.sourceHash,
      },
      update: {
        text,
        autoGenerated: options?.autoGenerated ?? false,
        sourceHash: options?.sourceHash,
        reviewed: false,  // Reset on update
      },
    });
  }

  async getSources(): Promise<SourceString[]> {
    const sources = await this.prisma.rosettaSource.findMany({
      select: { hash: true, text: true, context: true },
    });

    return sources;
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    const sources = await this.prisma.rosettaSource.findMany({
      where: {
        NOT: {
          hash: {
            in: await this.prisma.rosettaTranslation
              .findMany({
                where: { locale },
                select: { hash: true },
              })
              .then(t => t.map(x => x.hash)),
          },
        },
      },
      select: { hash: true, text: true, context: true },
    });

    return sources;
  }

  async getAvailableLocales(): Promise<string[]> {
    const locales = await this.prisma.rosettaTranslation.findMany({
      distinct: ['locale'],
      select: { locale: true },
    });

    return locales.map(l => l.locale);
  }

  // Admin methods
  async markAsReviewed(locale: string, hash: string): Promise<void> {
    await this.prisma.rosettaTranslation.update({
      where: { locale_hash: { locale, hash } },
      data: { reviewed: true },
    });
  }

  async getSourcesWithTranslations(
    locales: string[]
  ): Promise<SourceWithTranslations[]> {
    const sources = await this.prisma.rosettaSource.findMany();
    const translations = await this.prisma.rosettaTranslation.findMany({
      where: { locale: { in: locales } },
    });

    // Index translations by hash and locale
    const translationMap = new Map<string, Map<string, typeof translations[0]>>();
    for (const t of translations) {
      if (!translationMap.has(t.hash)) {
        translationMap.set(t.hash, new Map());
      }
      translationMap.get(t.hash)!.set(t.locale, t);
    }

    return sources.map(source => ({
      hash: source.hash,
      text: source.text,
      context: source.context,
      translations: Object.fromEntries(
        locales.map(locale => {
          const t = translationMap.get(source.hash)?.get(locale);
          return [
            locale,
            t ? {
              text: t.text,
              autoGenerated: t.autoGenerated,
              reviewed: t.reviewed,
              sourceHash: t.sourceHash,
              translatedFrom: null,
            } : null,
          ];
        })
      ),
    }));
  }
}
```

### Usage

```ts
// lib/rosetta/index.ts
import { Rosetta } from '@sylphx/rosetta/server';
import { PrismaClient } from '@prisma/client';
import { PrismaStorageAdapter } from './prisma-adapter';

const prisma = new PrismaClient();

export const rosetta = new Rosetta({
  storage: new PrismaStorageAdapter(prisma),
  defaultLocale: 'en',
});
```

## Example: MongoDB Adapter

### Schema Design

```ts
// Collections:
// rosetta_sources: { hash, text, context, occurrences, firstSeenAt, lastSeenAt }
// rosetta_translations: { locale, hash, text, sourceHash, autoGenerated, reviewed, createdAt, updatedAt }
```

### Adapter Implementation

```ts
// lib/rosetta/mongodb-adapter.ts
import { MongoClient, Collection, Db } from 'mongodb';
import type {
  StorageAdapter,
  SourceString,
  SaveTranslationOptions,
} from '@sylphx/rosetta';

interface SourceDocument {
  hash: string;
  text: string;
  context?: string;
}

interface TranslationDocument {
  locale: string;
  hash: string;
  text: string;
  sourceHash?: string;
  autoGenerated: boolean;
  reviewed: boolean;
}

export class MongoDBStorageAdapter implements StorageAdapter {
  private sources: Collection<SourceDocument>;
  private translations: Collection<TranslationDocument>;

  constructor(db: Db) {
    this.sources = db.collection('rosetta_sources');
    this.translations = db.collection('rosetta_translations');
  }

  async getTranslations(locale: string): Promise<Map<string, string>> {
    const docs = await this.translations
      .find({ locale })
      .project({ hash: 1, text: 1 })
      .toArray();

    return new Map(docs.map(d => [d.hash, d.text]));
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string,
    options?: SaveTranslationOptions
  ): Promise<void> {
    await this.translations.updateOne(
      { locale, hash },
      {
        $set: {
          text,
          autoGenerated: options?.autoGenerated ?? false,
          sourceHash: options?.sourceHash,
          reviewed: false,
          updatedAt: new Date(),
        },
        $setOnInsert: {
          createdAt: new Date(),
        },
      },
      { upsert: true }
    );
  }

  async getSources(): Promise<SourceString[]> {
    return this.sources
      .find()
      .project<SourceString>({ _id: 0, hash: 1, text: 1, context: 1 })
      .toArray();
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    const translatedHashes = await this.translations
      .distinct('hash', { locale });

    return this.sources
      .find({ hash: { $nin: translatedHashes } })
      .project<SourceString>({ _id: 0, hash: 1, text: 1, context: 1 })
      .toArray();
  }

  async getAvailableLocales(): Promise<string[]> {
    return this.translations.distinct('locale');
  }

  async markAsReviewed(locale: string, hash: string): Promise<void> {
    await this.translations.updateOne(
      { locale, hash },
      { $set: { reviewed: true } }
    );
  }
}
```

## Example: REST API Adapter

Fetch translations from an external service:

```ts
// lib/rosetta/api-adapter.ts
import type {
  StorageAdapter,
  SourceString,
  SaveTranslationOptions,
} from '@sylphx/rosetta';

export class APIStorageAdapter implements StorageAdapter {
  constructor(
    private baseUrl: string,
    private apiKey: string
  ) {}

  private async fetch<T>(path: string, options?: RequestInit): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }

    return response.json();
  }

  async getTranslations(locale: string): Promise<Map<string, string>> {
    const data = await this.fetch<Record<string, string>>(
      `/translations/${locale}`
    );

    return new Map(Object.entries(data));
  }

  async saveTranslation(
    locale: string,
    hash: string,
    text: string,
    options?: SaveTranslationOptions
  ): Promise<void> {
    await this.fetch(`/translations/${locale}/${hash}`, {
      method: 'PUT',
      body: JSON.stringify({ text, ...options }),
    });
  }

  async getSources(): Promise<SourceString[]> {
    return this.fetch<SourceString[]>('/sources');
  }

  async getUntranslated(locale: string): Promise<SourceString[]> {
    return this.fetch<SourceString[]>(`/sources/untranslated/${locale}`);
  }

  async getAvailableLocales(): Promise<string[]> {
    return this.fetch<string[]>('/locales');
  }
}
```

## Testing Your Adapter

```ts
// lib/rosetta/__tests__/adapter.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';
import { PrismaStorageAdapter } from '../prisma-adapter';

describe('PrismaStorageAdapter', () => {
  let adapter: PrismaStorageAdapter;

  beforeAll(async () => {
    // Setup test database
    adapter = new PrismaStorageAdapter(testPrisma);
  });

  afterAll(async () => {
    // Cleanup
  });

  it('should save and retrieve translations', async () => {
    await adapter.saveTranslation('zh', 'abc123', '你好');

    const translations = await adapter.getTranslations('zh');
    expect(translations.get('abc123')).toBe('你好');
  });

  it('should track untranslated sources', async () => {
    // Add sources
    await testPrisma.rosettaSource.createMany({
      data: [
        { hash: 'hash1', text: 'Hello' },
        { hash: 'hash2', text: 'World' },
      ],
    });

    // Translate one
    await adapter.saveTranslation('zh', 'hash1', '你好');

    const untranslated = await adapter.getUntranslated('zh');
    expect(untranslated).toHaveLength(1);
    expect(untranslated[0].hash).toBe('hash2');
  });

  it('should mark translations as reviewed', async () => {
    await adapter.saveTranslation('zh', 'test123', '测试', {
      autoGenerated: true,
    });

    await adapter.markAsReviewed('zh', 'test123');

    const translation = await testPrisma.rosettaTranslation.findUnique({
      where: { locale_hash: { locale: 'zh', hash: 'test123' } },
    });

    expect(translation?.reviewed).toBe(true);
  });
});
```

## Performance Tips

### Add Indexes

```sql
-- Essential indexes
CREATE INDEX idx_translations_locale ON translations(locale);
CREATE INDEX idx_translations_hash ON translations(hash);
CREATE UNIQUE INDEX idx_translations_locale_hash ON translations(locale, hash);
CREATE UNIQUE INDEX idx_sources_hash ON sources(hash);
```

### Use Caching

```ts
import { InMemoryCache } from '@sylphx/rosetta/server';

const rosetta = new Rosetta({
  storage: myAdapter,
  cache: new InMemoryCache({
    ttlMs: 5 * 60 * 1000,
    maxEntries: 100,
  }),
});
```

### Batch Operations

```ts
async saveTranslations(
  locale: string,
  translations: Map<string, string>
): Promise<void> {
  const values = Array.from(translations.entries()).map(([hash, text]) => ({
    locale,
    hash,
    text,
  }));

  // Use batch insert
  await this.prisma.rosettaTranslation.createMany({
    data: values,
    skipDuplicates: true,
  });
}
```

## Next Steps

- [Storage Adapter Guide](/advanced/storage-adapter) - Full interface reference
- [Basic Setup](/examples/basic) - Complete project setup
- [Caching](/advanced/caching) - Optimize performance

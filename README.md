# @sylphx/lingua

Lightweight i18n library with **production-time string collection** and **LLM-powered translation**.

## Features

- **Zero config source strings** - Write English directly in code: `t("Hello World")`
- **Auto-collection** - Strings collected in production as users hit code paths
- **LLM translation** - Generate translations using OpenRouter, Anthropic, etc.
- **Server + Client** - Full Next.js App Router support with RSC
- **Type-safe** - Full TypeScript support
- **Adapter pattern** - Bring your own storage (Drizzle, Prisma, etc.)
- **Admin-ready** - Built-in methods for translation management dashboards

## Installation

```bash
bun add @sylphx/lingua

# Optional: Drizzle adapter with pre-built schema
bun add @sylphx/lingua-drizzle
```

## Quick Start

### 1. Set Up Database Schema (Drizzle)

**Option A: Use `@sylphx/lingua-drizzle` (Recommended)**

```typescript
// db/schema.ts
import { pgTable, text, timestamp, integer, boolean, unique, serial } from 'drizzle-orm/pg-core';
import { createLinguaSchema } from '@sylphx/lingua-drizzle/schema';

export const { linguaSources, linguaTranslations } = createLinguaSchema({
  pgTable, text, timestamp, integer, boolean, unique, serial
});

// Your other tables...
```

**Option B: Manual schema**

```typescript
// db/schema.ts
import { pgTable, text, timestamp, boolean, serial, unique } from 'drizzle-orm/pg-core';

export const linguaSources = pgTable('lingua_sources', {
  id: serial('id').primaryKey(),
  hash: text('hash').notNull().unique(),
  text: text('text').notNull(),
  context: text('context'),
  occurrences: integer('occurrences').default(1),
  firstSeenAt: timestamp('first_seen_at').defaultNow(),
  lastSeenAt: timestamp('last_seen_at').defaultNow(),
});

export const linguaTranslations = pgTable('lingua_translations', {
  id: serial('id').primaryKey(),
  locale: text('locale').notNull(),
  hash: text('hash').notNull(),
  text: text('text').notNull(),
  autoGenerated: boolean('auto_generated').default(false),
  reviewed: boolean('reviewed').default(false),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (t) => [unique().on(t.locale, t.hash)]);
```

### 2. Create Storage Adapter

**Option A: Use `@sylphx/lingua-drizzle` (Recommended)**

```typescript
// lib/i18n/storage.ts
import { DrizzleStorageAdapter } from '@sylphx/lingua-drizzle';
import { db } from '@/db';
import { linguaSources, linguaTranslations } from '@/db/schema';

export const storage = new DrizzleStorageAdapter({
  db,
  sources: linguaSources,
  translations: linguaTranslations,
});
```

**Option B: Implement `StorageAdapter` manually**

```typescript
// lib/i18n/storage.ts
import type { StorageAdapter } from '@sylphx/lingua';
import { db } from '@/db';
import { eq, inArray, notInArray } from 'drizzle-orm';
import { linguaSources, linguaTranslations } from '@/db/schema';

export const storage: StorageAdapter = {
  async getTranslations(locale) {
    const rows = await db
      .select({ hash: linguaTranslations.hash, text: linguaTranslations.text })
      .from(linguaTranslations)
      .where(eq(linguaTranslations.locale, locale));
    return new Map(rows.map(r => [r.hash, r.text]));
  },

  async registerSources(sources) {
    if (sources.length === 0) return;
    await db.insert(linguaSources)
      .values(sources.map(s => ({
        hash: s.hash,
        text: s.text,
        context: s.context,
      })))
      .onConflictDoNothing();
  },

  async saveTranslation(locale, hash, text, options) {
    await db.insert(linguaTranslations)
      .values({
        locale,
        hash,
        text,
        autoGenerated: options?.autoGenerated ?? false,
      })
      .onConflictDoUpdate({
        target: [linguaTranslations.locale, linguaTranslations.hash],
        set: { text, updatedAt: new Date() },
      });
  },

  async getSources() {
    return db.select().from(linguaSources);
  },

  async getUntranslated(locale) {
    const translated = await db
      .select({ hash: linguaTranslations.hash })
      .from(linguaTranslations)
      .where(eq(linguaTranslations.locale, locale));
    const hashes = translated.map(t => t.hash);

    if (hashes.length === 0) {
      return db.select().from(linguaSources);
    }
    return db.select().from(linguaSources)
      .where(notInArray(linguaSources.hash, hashes));
  },
};
```

### 3. Initialize I18n

```typescript
// lib/i18n/index.ts
import { I18n } from '@sylphx/lingua/server';
import { OpenRouterAdapter } from '@sylphx/lingua/adapters';
import { cookies } from 'next/headers';
import { storage } from './storage';

export const i18n = new I18n({
  storage,
  translator: new OpenRouterAdapter({
    apiKey: process.env.OPENROUTER_API_KEY!,
  }),
  defaultLocale: 'en',
  enabledLocales: ['en', 'zh-TW', 'zh-CN', 'ja'],
  localeDetector: async () => {
    const cookieStore = await cookies();
    return cookieStore.get('locale')?.value ?? 'en';
  },
});

export { t, flushCollectedStrings, getTranslationsForClient, getLocale } from '@sylphx/lingua/server';
```

### 4. Set Up Layout

```tsx
// app/layout.tsx
import { i18n, flushCollectedStrings, getTranslationsForClient, getLocale } from '@/lib/i18n';
import { I18nProvider } from '@sylphx/lingua/client';

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  return i18n.init(async () => {
    const content = (
      <html lang={getLocale()}>
        <body>
          <I18nProvider
            locale={getLocale()}
            translations={getTranslationsForClient()}
          >
            {children}
          </I18nProvider>
        </body>
      </html>
    );

    // Flush collected strings at end of request
    await flushCollectedStrings();
    return content;
  });
}
```

### 5. Use Translations

**Server Components:**
```tsx
import { t } from '@/lib/i18n';

export function ServerComponent() {
  return (
    <div>
      <h1>{t("Welcome to our app")}</h1>
      <p>{t("Hello {name}", { name: "World" })}</p>
    </div>
  );
}
```

**Client Components:**
```tsx
'use client';
import { useT } from '@sylphx/lingua/client';

export function ClientComponent() {
  const t = useT();
  return <button>{t("Sign In")}</button>;
}
```

## Admin Dashboard

### API Routes

Create API routes to manage translations:

```typescript
// app/api/i18n/sources/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// GET /api/i18n/sources - Get all sources with translation status
export async function GET() {
  const sources = await i18n.getSourcesWithStatus();
  return NextResponse.json(sources);
}
```

```typescript
// app/api/i18n/stats/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// GET /api/i18n/stats - Get translation statistics
export async function GET() {
  const stats = await i18n.getStats();
  return NextResponse.json(stats);
}
```

```typescript
// app/api/i18n/translate/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// POST /api/i18n/translate - Generate translation for a string
export async function POST(req: Request) {
  const { text, locale, context } = await req.json();
  const translation = await i18n.generateAndSave(text, locale, context);
  return NextResponse.json({ translation });
}
```

```typescript
// app/api/i18n/translate/batch/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// POST /api/i18n/translate/batch - Batch translate strings
export async function POST(req: Request) {
  const { items, locale } = await req.json();
  const result = await i18n.batchTranslate(items, locale);
  return NextResponse.json(result);
}
```

```typescript
// app/api/i18n/translations/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// PUT /api/i18n/translations - Save manual translation
export async function PUT(req: Request) {
  const { locale, hash, text } = await req.json();
  await i18n.saveTranslationByHash(locale, hash, text, { autoGenerated: false });
  return NextResponse.json({ success: true });
}
```

```typescript
// app/api/i18n/review/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// POST /api/i18n/review - Mark translation as reviewed
export async function POST(req: Request) {
  const { hash, locale } = await req.json();
  await i18n.markAsReviewed(hash, locale);
  return NextResponse.json({ success: true });
}
```

```typescript
// app/api/i18n/export/route.ts
import { i18n } from '@/lib/i18n';
import { NextResponse } from 'next/server';

// GET /api/i18n/export?locale=zh-TW - Export translations
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const locale = searchParams.get('locale') ?? 'zh-TW';
  const data = await i18n.exportTranslations(locale);
  return NextResponse.json(data);
}

// POST /api/i18n/export - Import translations
export async function POST(req: Request) {
  const { locale, data } = await req.json();
  const count = await i18n.importTranslations(locale, data);
  return NextResponse.json({ imported: count });
}
```

### Admin UI Example

```tsx
'use client';

import { useState, useEffect } from 'react';

interface Source {
  id: string;
  text: string;
  hash: string;
  context?: string;
  translations: Record<string, {
    text: string | null;
    autoGenerated: boolean;
    reviewed: boolean;
  } | null>;
}

export function TranslationDashboard() {
  const [sources, setSources] = useState<Source[]>([]);
  const [stats, setStats] = useState<any>(null);
  const [selectedLocale, setSelectedLocale] = useState('zh-TW');

  useEffect(() => {
    fetch('/api/i18n/sources').then(r => r.json()).then(setSources);
    fetch('/api/i18n/stats').then(r => r.json()).then(setStats);
  }, []);

  const handleTranslate = async (source: Source) => {
    const res = await fetch('/api/i18n/translate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: source.text,
        locale: selectedLocale,
        context: source.context,
      }),
    });
    const { translation } = await res.json();
    // Refresh sources
    fetch('/api/i18n/sources').then(r => r.json()).then(setSources);
  };

  const handleBatchTranslate = async () => {
    const untranslated = sources.filter(s => !s.translations[selectedLocale]);
    await fetch('/api/i18n/translate/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        items: untranslated.map(s => ({ hash: s.hash, text: s.text, context: s.context })),
        locale: selectedLocale,
      }),
    });
    fetch('/api/i18n/sources').then(r => r.json()).then(setSources);
  };

  return (
    <div>
      <h1>Translation Dashboard</h1>

      {stats && (
        <div>
          <p>Total strings: {stats.totalStrings}</p>
          <p>Translated ({selectedLocale}): {stats.locales[selectedLocale]?.translated ?? 0}</p>
        </div>
      )}

      <select value={selectedLocale} onChange={e => setSelectedLocale(e.target.value)}>
        <option value="zh-TW">Chinese (Traditional)</option>
        <option value="zh-CN">Chinese (Simplified)</option>
        <option value="ja">Japanese</option>
      </select>

      <button onClick={handleBatchTranslate}>
        Translate All Missing
      </button>

      <table>
        <thead>
          <tr>
            <th>Source</th>
            <th>Translation</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {sources.map(source => {
            const translation = source.translations[selectedLocale];
            return (
              <tr key={source.hash}>
                <td>{source.text}</td>
                <td>{translation?.text ?? '-'}</td>
                <td>
                  {!translation ? 'Missing' :
                   translation.reviewed ? 'Reviewed' :
                   translation.autoGenerated ? 'Auto' : 'Manual'}
                </td>
                <td>
                  {!translation && (
                    <button onClick={() => handleTranslate(source)}>
                      Translate
                    </button>
                  )}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}
```

## How It Works

```
┌─────────────────────────────────────────────────────────────────┐
│  PRODUCTION                                                      │
│  Real users → t("Hello") → 1. Return translation                │
│                           → 2. Queue for collection (async)     │
│                                                                  │
│  End of request → flushCollectedStrings() → Save to DB          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  ADMIN DASHBOARD                                                 │
│  • View all collected strings (getSourcesWithStatus)            │
│  • LLM auto-translate (batchTranslate / generateAndSave)        │
│  • Manual translation / review (saveTranslationByHash)          │
│  • Export → External tools → Import                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  PRODUCTION (after translations saved)                          │
│  Users → t("Hello") → DB lookup → Return "你好"                 │
└─────────────────────────────────────────────────────────────────┘
```

## API Reference

### Server (`@sylphx/lingua/server`)

#### `I18n` class

```typescript
const i18n = new I18n({
  storage: StorageAdapter,       // Required: your storage adapter
  translator?: TranslateAdapter, // Optional: for auto-translation
  defaultLocale?: string,        // Default: 'en'
  enabledLocales?: string[],     // Default: ['en', 'zh-TW', 'zh-CN']
  cacheTTL?: number,             // Default: 60000 (1 minute)
  localeDetector?: () => string, // Function to detect current locale
});

// Core methods
await i18n.init(fn)                  // Initialize context and run function
await i18n.getClientData()           // Get data for client hydration
await i18n.loadTranslations(locale)  // Load translations for a locale

// Source/translation management
await i18n.getSources()              // Get all source strings
await i18n.getUntranslated(locale)   // Get untranslated strings for locale
await i18n.saveTranslation(locale, text, translation, context?)

// Auto-translation
await i18n.generateTranslation(text, locale, context?)
await i18n.generateAndSave(text, locale, context?)
await i18n.generateAllUntranslated(locale, onProgress?)
await i18n.batchTranslate(items, locale)

// Admin methods
await i18n.getSourcesWithStatus()    // Get sources with translation status
await i18n.getStats()                // Get translation statistics
await i18n.markAsReviewed(hash, locale)
await i18n.saveTranslationByHash(locale, hash, text, options?)
await i18n.exportTranslations(locale)
await i18n.importTranslations(locale, data, options?)

// Utilities
i18n.getEnabledLocales()             // Get list of enabled locales
i18n.getDefaultLocale()              // Get default locale
i18n.getTargetLocales()              // Get non-default locales
i18n.invalidateCache()               // Clear translation cache
```

#### `t(text, params?)` function

```typescript
t("Hello World")                      // Simple translation
t("Hello {name}", { name: "John" })   // With interpolation
t("Submit", { context: "form" })      // With context for disambiguation
```

#### Other exports

```typescript
flushCollectedStrings()    // Flush pending strings to storage
getLocale()                // Get current locale
getTranslationsForClient() // Get translations for client provider
```

### Client (`@sylphx/lingua/client`)

```tsx
<I18nProvider locale="en" translations={translations}>
  {children}
</I18nProvider>

const t = useT();           // Get translation function
const locale = useLocale(); // Get current locale
```

### Adapters (`@sylphx/lingua/adapters`)

```typescript
import { OpenRouterAdapter } from '@sylphx/lingua/adapters';

const translator = new OpenRouterAdapter({
  apiKey: string,           // Required
  model?: string,           // Default: 'openai/gpt-4.1-mini'
  temperature?: number,     // Default: 0.3
  maxTokens?: number,       // Default: 500
});
```

### Drizzle Package (`@sylphx/lingua-drizzle`)

```typescript
// Schema helpers
import { createLinguaSchema } from '@sylphx/lingua-drizzle/schema';
import { createLinguaSchemaSQLite } from '@sylphx/lingua-drizzle/schema';
import { createLinguaSchemaMySQL } from '@sylphx/lingua-drizzle/schema';

// Storage adapter
import { DrizzleStorageAdapter } from '@sylphx/lingua-drizzle';

const storage = new DrizzleStorageAdapter({
  db,                    // Drizzle database instance
  sources: linguaSources,     // Sources table from schema
  translations: linguaTranslations, // Translations table from schema
});
```

## Supported Databases

The `@sylphx/lingua-drizzle` package supports:

- **PostgreSQL** - `createLinguaSchema()`
- **SQLite** - `createLinguaSchemaSQLite()`
- **MySQL** - `createLinguaSchemaMySQL()`

## License

MIT
